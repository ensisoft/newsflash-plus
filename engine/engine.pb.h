// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: engine.proto

#ifndef PROTOBUF_engine_2eproto__INCLUDED
#define PROTOBUF_engine_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace data {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_engine_2eproto();
void protobuf_AssignDesc_engine_2eproto();
void protobuf_ShutdownFile_engine_2eproto();

class File;
class Stash;
class Download;
class TaskState;
class Batch;
class TaskList;

// ===================================================================

class File : public ::google::protobuf::Message {
 public:
  File();
  virtual ~File();

  File(const File& from);

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const File& default_instance();

  void Swap(File* other);

  // implements Message ----------------------------------------------

  File* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const File& from);
  void MergeFrom(const File& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // required string filepath = 2;
  inline bool has_filepath() const;
  inline void clear_filepath();
  static const int kFilepathFieldNumber = 2;
  inline const ::std::string& filepath() const;
  inline void set_filepath(const ::std::string& value);
  inline void set_filepath(const char* value);
  inline void set_filepath(const char* value, size_t size);
  inline ::std::string* mutable_filepath();
  inline ::std::string* release_filepath();
  inline void set_allocated_filepath(::std::string* filepath);

  // required string dataname = 3;
  inline bool has_dataname() const;
  inline void clear_dataname();
  static const int kDatanameFieldNumber = 3;
  inline const ::std::string& dataname() const;
  inline void set_dataname(const ::std::string& value);
  inline void set_dataname(const char* value);
  inline void set_dataname(const char* value, size_t size);
  inline ::std::string* mutable_dataname();
  inline ::std::string* release_dataname();
  inline void set_allocated_dataname(::std::string* dataname);

  // required bool is_binary = 4;
  inline bool has_is_binary() const;
  inline void clear_is_binary();
  static const int kIsBinaryFieldNumber = 4;
  inline bool is_binary() const;
  inline void set_is_binary(bool value);

  // @@protoc_insertion_point(class_scope:data.File)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_filepath();
  inline void clear_has_filepath();
  inline void set_has_dataname();
  inline void clear_has_dataname();
  inline void set_has_is_binary();
  inline void clear_has_is_binary();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* filename_;
  ::std::string* filepath_;
  ::std::string* dataname_;
  bool is_binary_;
  friend void  protobuf_AddDesc_engine_2eproto();
  friend void protobuf_AssignDesc_engine_2eproto();
  friend void protobuf_ShutdownFile_engine_2eproto();

  void InitAsDefaultInstance();
  static File* default_instance_;
};
// -------------------------------------------------------------------

class Stash : public ::google::protobuf::Message {
 public:
  Stash();
  virtual ~Stash();

  Stash(const Stash& from);

  inline Stash& operator=(const Stash& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stash& default_instance();

  void Swap(Stash* other);

  // implements Message ----------------------------------------------

  Stash* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stash& from);
  void MergeFrom(const Stash& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 sequence = 1;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  inline ::google::protobuf::uint32 sequence() const;
  inline void set_sequence(::google::protobuf::uint32 value);

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:data.Stash)
 private:
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* data_;
  ::google::protobuf::uint32 sequence_;
  friend void  protobuf_AddDesc_engine_2eproto();
  friend void protobuf_AssignDesc_engine_2eproto();
  friend void protobuf_ShutdownFile_engine_2eproto();

  void InitAsDefaultInstance();
  static Stash* default_instance_;
};
// -------------------------------------------------------------------

class Download : public ::google::protobuf::Message {
 public:
  Download();
  virtual ~Download();

  Download(const Download& from);

  inline Download& operator=(const Download& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Download& default_instance();

  void Swap(Download* other);

  // implements Message ----------------------------------------------

  Download* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Download& from);
  void MergeFrom(const Download& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string article = 1;
  inline int article_size() const;
  inline void clear_article();
  static const int kArticleFieldNumber = 1;
  inline const ::std::string& article(int index) const;
  inline ::std::string* mutable_article(int index);
  inline void set_article(int index, const ::std::string& value);
  inline void set_article(int index, const char* value);
  inline void set_article(int index, const char* value, size_t size);
  inline ::std::string* add_article();
  inline void add_article(const ::std::string& value);
  inline void add_article(const char* value);
  inline void add_article(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& article() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_article();

  // repeated string group = 2;
  inline int group_size() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 2;
  inline const ::std::string& group(int index) const;
  inline ::std::string* mutable_group(int index);
  inline void set_group(int index, const ::std::string& value);
  inline void set_group(int index, const char* value);
  inline void set_group(int index, const char* value, size_t size);
  inline ::std::string* add_group();
  inline void add_group(const ::std::string& value);
  inline void add_group(const char* value);
  inline void add_group(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& group() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_group();

  // required string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required string name = 4;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 4;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string stash_name = 5;
  inline bool has_stash_name() const;
  inline void clear_stash_name();
  static const int kStashNameFieldNumber = 5;
  inline const ::std::string& stash_name() const;
  inline void set_stash_name(const ::std::string& value);
  inline void set_stash_name(const char* value);
  inline void set_stash_name(const char* value, size_t size);
  inline ::std::string* mutable_stash_name();
  inline ::std::string* release_stash_name();
  inline void set_allocated_stash_name(::std::string* stash_name);

  // required uint32 num_decode_jobs = 6;
  inline bool has_num_decode_jobs() const;
  inline void clear_num_decode_jobs();
  static const int kNumDecodeJobsFieldNumber = 6;
  inline ::google::protobuf::uint32 num_decode_jobs() const;
  inline void set_num_decode_jobs(::google::protobuf::uint32 value);

  // required uint32 num_actions_total = 7;
  inline bool has_num_actions_total() const;
  inline void clear_num_actions_total();
  static const int kNumActionsTotalFieldNumber = 7;
  inline ::google::protobuf::uint32 num_actions_total() const;
  inline void set_num_actions_total(::google::protobuf::uint32 value);

  // required uint32 num_actions_ready = 8;
  inline bool has_num_actions_ready() const;
  inline void clear_num_actions_ready();
  static const int kNumActionsReadyFieldNumber = 8;
  inline ::google::protobuf::uint32 num_actions_ready() const;
  inline void set_num_actions_ready(::google::protobuf::uint32 value);

  // required uint32 errors = 9;
  inline bool has_errors() const;
  inline void clear_errors();
  static const int kErrorsFieldNumber = 9;
  inline ::google::protobuf::uint32 errors() const;
  inline void set_errors(::google::protobuf::uint32 value);

  // repeated .data.File file = 10;
  inline int file_size() const;
  inline void clear_file();
  static const int kFileFieldNumber = 10;
  inline const ::data::File& file(int index) const;
  inline ::data::File* mutable_file(int index);
  inline ::data::File* add_file();
  inline const ::google::protobuf::RepeatedPtrField< ::data::File >&
      file() const;
  inline ::google::protobuf::RepeatedPtrField< ::data::File >*
      mutable_file();

  // repeated .data.Stash stash = 11;
  inline int stash_size() const;
  inline void clear_stash();
  static const int kStashFieldNumber = 11;
  inline const ::data::Stash& stash(int index) const;
  inline ::data::Stash* mutable_stash(int index);
  inline ::data::Stash* add_stash();
  inline const ::google::protobuf::RepeatedPtrField< ::data::Stash >&
      stash() const;
  inline ::google::protobuf::RepeatedPtrField< ::data::Stash >*
      mutable_stash();

  // @@protoc_insertion_point(class_scope:data.Download)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_stash_name();
  inline void clear_has_stash_name();
  inline void set_has_num_decode_jobs();
  inline void clear_has_num_decode_jobs();
  inline void set_has_num_actions_total();
  inline void clear_has_num_actions_total();
  inline void set_has_num_actions_ready();
  inline void clear_has_num_actions_ready();
  inline void set_has_errors();
  inline void clear_has_errors();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> article_;
  ::google::protobuf::RepeatedPtrField< ::std::string> group_;
  ::std::string* path_;
  ::std::string* name_;
  ::std::string* stash_name_;
  ::google::protobuf::uint32 num_decode_jobs_;
  ::google::protobuf::uint32 num_actions_total_;
  ::google::protobuf::uint32 num_actions_ready_;
  ::google::protobuf::uint32 errors_;
  ::google::protobuf::RepeatedPtrField< ::data::File > file_;
  ::google::protobuf::RepeatedPtrField< ::data::Stash > stash_;
  friend void  protobuf_AddDesc_engine_2eproto();
  friend void protobuf_AssignDesc_engine_2eproto();
  friend void protobuf_ShutdownFile_engine_2eproto();

  void InitAsDefaultInstance();
  static Download* default_instance_;
};
// -------------------------------------------------------------------

class TaskState : public ::google::protobuf::Message {
 public:
  TaskState();
  virtual ~TaskState();

  TaskState(const TaskState& from);

  inline TaskState& operator=(const TaskState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskState& default_instance();

  void Swap(TaskState* other);

  // implements Message ----------------------------------------------

  TaskState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskState& from);
  void MergeFrom(const TaskState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 task_id = 1;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 1;
  inline ::google::protobuf::uint32 task_id() const;
  inline void set_task_id(::google::protobuf::uint32 value);

  // required uint32 account_id = 2;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 2;
  inline ::google::protobuf::uint32 account_id() const;
  inline void set_account_id(::google::protobuf::uint32 value);

  // required uint32 batch_id = 3;
  inline bool has_batch_id() const;
  inline void clear_batch_id();
  static const int kBatchIdFieldNumber = 3;
  inline ::google::protobuf::uint32 batch_id() const;
  inline void set_batch_id(::google::protobuf::uint32 value);

  // required string desc = 4;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 4;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // required string path = 5;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 5;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required uint64 size = 6;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 6;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);

  // required uint32 type = 7;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 7;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 state = 8;
  inline bool has_state() const;
  inline void clear_state();
  static const int kStateFieldNumber = 8;
  inline ::google::protobuf::uint32 state() const;
  inline void set_state(::google::protobuf::uint32 value);

  // required uint32 errors = 9;
  inline bool has_errors() const;
  inline void clear_errors();
  static const int kErrorsFieldNumber = 9;
  inline ::google::protobuf::uint32 errors() const;
  inline void set_errors(::google::protobuf::uint32 value);

  // required uint32 runtime = 10;
  inline bool has_runtime() const;
  inline void clear_runtime();
  static const int kRuntimeFieldNumber = 10;
  inline ::google::protobuf::uint32 runtime() const;
  inline void set_runtime(::google::protobuf::uint32 value);

  // required bytes data = 11;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 11;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:data.TaskState)
 private:
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_batch_id();
  inline void clear_has_batch_id();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_state();
  inline void clear_has_state();
  inline void set_has_errors();
  inline void clear_has_errors();
  inline void set_has_runtime();
  inline void clear_has_runtime();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 task_id_;
  ::google::protobuf::uint32 account_id_;
  ::std::string* desc_;
  ::std::string* path_;
  ::google::protobuf::uint32 batch_id_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint64 size_;
  ::google::protobuf::uint32 state_;
  ::google::protobuf::uint32 errors_;
  ::std::string* data_;
  ::google::protobuf::uint32 runtime_;
  friend void  protobuf_AddDesc_engine_2eproto();
  friend void protobuf_AssignDesc_engine_2eproto();
  friend void protobuf_ShutdownFile_engine_2eproto();

  void InitAsDefaultInstance();
  static TaskState* default_instance_;
};
// -------------------------------------------------------------------

class Batch : public ::google::protobuf::Message {
 public:
  Batch();
  virtual ~Batch();

  Batch(const Batch& from);

  inline Batch& operator=(const Batch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Batch& default_instance();

  void Swap(Batch* other);

  // implements Message ----------------------------------------------

  Batch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Batch& from);
  void MergeFrom(const Batch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline ::google::protobuf::uint32 account_id() const;
  inline void set_account_id(::google::protobuf::uint32 value);

  // required uint32 batch_id = 2;
  inline bool has_batch_id() const;
  inline void clear_batch_id();
  static const int kBatchIdFieldNumber = 2;
  inline ::google::protobuf::uint32 batch_id() const;
  inline void set_batch_id(::google::protobuf::uint32 value);

  // required string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required string desc = 4;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 4;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // required uint64 byte_size = 5;
  inline bool has_byte_size() const;
  inline void clear_byte_size();
  static const int kByteSizeFieldNumber = 5;
  inline ::google::protobuf::uint64 byte_size() const;
  inline void set_byte_size(::google::protobuf::uint64 value);

  // required uint32 num_tasks = 6;
  inline bool has_num_tasks() const;
  inline void clear_num_tasks();
  static const int kNumTasksFieldNumber = 6;
  inline ::google::protobuf::uint32 num_tasks() const;
  inline void set_num_tasks(::google::protobuf::uint32 value);

  // required uint32 num_files = 7;
  inline bool has_num_files() const;
  inline void clear_num_files();
  static const int kNumFilesFieldNumber = 7;
  inline ::google::protobuf::uint32 num_files() const;
  inline void set_num_files(::google::protobuf::uint32 value);

  // required bool damaged = 8;
  inline bool has_damaged() const;
  inline void clear_damaged();
  static const int kDamagedFieldNumber = 8;
  inline bool damaged() const;
  inline void set_damaged(bool value);

  // required float completion = 9;
  inline bool has_completion() const;
  inline void clear_completion();
  static const int kCompletionFieldNumber = 9;
  inline float completion() const;
  inline void set_completion(float value);

  // required uint32 type = 10;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 10;
  inline ::google::protobuf::uint32 type() const;
  inline void set_type(::google::protobuf::uint32 value);

  // required uint32 runtime = 11;
  inline bool has_runtime() const;
  inline void clear_runtime();
  static const int kRuntimeFieldNumber = 11;
  inline ::google::protobuf::uint32 runtime() const;
  inline void set_runtime(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:data.Batch)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_batch_id();
  inline void clear_has_batch_id();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_byte_size();
  inline void clear_has_byte_size();
  inline void set_has_num_tasks();
  inline void clear_has_num_tasks();
  inline void set_has_num_files();
  inline void clear_has_num_files();
  inline void set_has_damaged();
  inline void clear_has_damaged();
  inline void set_has_completion();
  inline void clear_has_completion();
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_runtime();
  inline void clear_has_runtime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 account_id_;
  ::google::protobuf::uint32 batch_id_;
  ::std::string* path_;
  ::std::string* desc_;
  ::google::protobuf::uint64 byte_size_;
  ::google::protobuf::uint32 num_tasks_;
  ::google::protobuf::uint32 num_files_;
  bool damaged_;
  float completion_;
  ::google::protobuf::uint32 type_;
  ::google::protobuf::uint32 runtime_;
  friend void  protobuf_AddDesc_engine_2eproto();
  friend void protobuf_AssignDesc_engine_2eproto();
  friend void protobuf_ShutdownFile_engine_2eproto();

  void InitAsDefaultInstance();
  static Batch* default_instance_;
};
// -------------------------------------------------------------------

class TaskList : public ::google::protobuf::Message {
 public:
  TaskList();
  virtual ~TaskList();

  TaskList(const TaskList& from);

  inline TaskList& operator=(const TaskList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskList& default_instance();

  void Swap(TaskList* other);

  // implements Message ----------------------------------------------

  TaskList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskList& from);
  void MergeFrom(const TaskList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 bytes_queued = 1;
  inline bool has_bytes_queued() const;
  inline void clear_bytes_queued();
  static const int kBytesQueuedFieldNumber = 1;
  inline ::google::protobuf::uint64 bytes_queued() const;
  inline void set_bytes_queued(::google::protobuf::uint64 value);

  // required uint64 bytes_ready = 2;
  inline bool has_bytes_ready() const;
  inline void clear_bytes_ready();
  static const int kBytesReadyFieldNumber = 2;
  inline ::google::protobuf::uint64 bytes_ready() const;
  inline void set_bytes_ready(::google::protobuf::uint64 value);

  // required uint64 object_id = 3;
  inline bool has_object_id() const;
  inline void clear_object_id();
  static const int kObjectIdFieldNumber = 3;
  inline ::google::protobuf::uint64 object_id() const;
  inline void set_object_id(::google::protobuf::uint64 value);

  // repeated .data.Batch batch = 4;
  inline int batch_size() const;
  inline void clear_batch();
  static const int kBatchFieldNumber = 4;
  inline const ::data::Batch& batch(int index) const;
  inline ::data::Batch* mutable_batch(int index);
  inline ::data::Batch* add_batch();
  inline const ::google::protobuf::RepeatedPtrField< ::data::Batch >&
      batch() const;
  inline ::google::protobuf::RepeatedPtrField< ::data::Batch >*
      mutable_batch();

  // repeated .data.TaskState tasks = 5;
  inline int tasks_size() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 5;
  inline const ::data::TaskState& tasks(int index) const;
  inline ::data::TaskState* mutable_tasks(int index);
  inline ::data::TaskState* add_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::data::TaskState >&
      tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::data::TaskState >*
      mutable_tasks();

  // @@protoc_insertion_point(class_scope:data.TaskList)
 private:
  inline void set_has_bytes_queued();
  inline void clear_has_bytes_queued();
  inline void set_has_bytes_ready();
  inline void clear_has_bytes_ready();
  inline void set_has_object_id();
  inline void clear_has_object_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 bytes_queued_;
  ::google::protobuf::uint64 bytes_ready_;
  ::google::protobuf::uint64 object_id_;
  ::google::protobuf::RepeatedPtrField< ::data::Batch > batch_;
  ::google::protobuf::RepeatedPtrField< ::data::TaskState > tasks_;
  friend void  protobuf_AddDesc_engine_2eproto();
  friend void protobuf_AssignDesc_engine_2eproto();
  friend void protobuf_ShutdownFile_engine_2eproto();

  void InitAsDefaultInstance();
  static TaskList* default_instance_;
};
// ===================================================================


// ===================================================================

// File

// required string filename = 1;
inline bool File::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void File::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void File::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void File::clear_filename() {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& File::filename() const {
  // @@protoc_insertion_point(field_get:data.File.filename)
  return *filename_;
}
inline void File::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set:data.File.filename)
}
inline void File::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.File.filename)
}
inline void File::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.File.filename)
}
inline ::std::string* File::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.File.filename)
  return filename_;
}
inline ::std::string* File::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void File::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.File.filename)
}

// required string filepath = 2;
inline bool File::has_filepath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void File::set_has_filepath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void File::clear_has_filepath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void File::clear_filepath() {
  if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_->clear();
  }
  clear_has_filepath();
}
inline const ::std::string& File::filepath() const {
  // @@protoc_insertion_point(field_get:data.File.filepath)
  return *filepath_;
}
inline void File::set_filepath(const ::std::string& value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
  // @@protoc_insertion_point(field_set:data.File.filepath)
}
inline void File::set_filepath(const char* value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.File.filepath)
}
inline void File::set_filepath(const char* value, size_t size) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.File.filepath)
}
inline ::std::string* File::mutable_filepath() {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.File.filepath)
  return filepath_;
}
inline ::std::string* File::release_filepath() {
  clear_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filepath_;
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void File::set_allocated_filepath(::std::string* filepath) {
  if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filepath_;
  }
  if (filepath) {
    set_has_filepath();
    filepath_ = filepath;
  } else {
    clear_has_filepath();
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.File.filepath)
}

// required string dataname = 3;
inline bool File::has_dataname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void File::set_has_dataname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void File::clear_has_dataname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void File::clear_dataname() {
  if (dataname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataname_->clear();
  }
  clear_has_dataname();
}
inline const ::std::string& File::dataname() const {
  // @@protoc_insertion_point(field_get:data.File.dataname)
  return *dataname_;
}
inline void File::set_dataname(const ::std::string& value) {
  set_has_dataname();
  if (dataname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataname_ = new ::std::string;
  }
  dataname_->assign(value);
  // @@protoc_insertion_point(field_set:data.File.dataname)
}
inline void File::set_dataname(const char* value) {
  set_has_dataname();
  if (dataname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataname_ = new ::std::string;
  }
  dataname_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.File.dataname)
}
inline void File::set_dataname(const char* value, size_t size) {
  set_has_dataname();
  if (dataname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataname_ = new ::std::string;
  }
  dataname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.File.dataname)
}
inline ::std::string* File::mutable_dataname() {
  set_has_dataname();
  if (dataname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.File.dataname)
  return dataname_;
}
inline ::std::string* File::release_dataname() {
  clear_has_dataname();
  if (dataname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dataname_;
    dataname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void File::set_allocated_dataname(::std::string* dataname) {
  if (dataname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dataname_;
  }
  if (dataname) {
    set_has_dataname();
    dataname_ = dataname;
  } else {
    clear_has_dataname();
    dataname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.File.dataname)
}

// required bool is_binary = 4;
inline bool File::has_is_binary() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void File::set_has_is_binary() {
  _has_bits_[0] |= 0x00000008u;
}
inline void File::clear_has_is_binary() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void File::clear_is_binary() {
  is_binary_ = false;
  clear_has_is_binary();
}
inline bool File::is_binary() const {
  // @@protoc_insertion_point(field_get:data.File.is_binary)
  return is_binary_;
}
inline void File::set_is_binary(bool value) {
  set_has_is_binary();
  is_binary_ = value;
  // @@protoc_insertion_point(field_set:data.File.is_binary)
}

// -------------------------------------------------------------------

// Stash

// required uint32 sequence = 1;
inline bool Stash::has_sequence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stash::set_has_sequence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stash::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stash::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 Stash::sequence() const {
  // @@protoc_insertion_point(field_get:data.Stash.sequence)
  return sequence_;
}
inline void Stash::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:data.Stash.sequence)
}

// required bytes data = 2;
inline bool Stash::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stash::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stash::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stash::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Stash::data() const {
  // @@protoc_insertion_point(field_get:data.Stash.data)
  return *data_;
}
inline void Stash::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:data.Stash.data)
}
inline void Stash::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.Stash.data)
}
inline void Stash::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.Stash.data)
}
inline ::std::string* Stash::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.Stash.data)
  return data_;
}
inline ::std::string* Stash::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Stash::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.Stash.data)
}

// -------------------------------------------------------------------

// Download

// repeated string article = 1;
inline int Download::article_size() const {
  return article_.size();
}
inline void Download::clear_article() {
  article_.Clear();
}
inline const ::std::string& Download::article(int index) const {
  // @@protoc_insertion_point(field_get:data.Download.article)
  return article_.Get(index);
}
inline ::std::string* Download::mutable_article(int index) {
  // @@protoc_insertion_point(field_mutable:data.Download.article)
  return article_.Mutable(index);
}
inline void Download::set_article(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:data.Download.article)
  article_.Mutable(index)->assign(value);
}
inline void Download::set_article(int index, const char* value) {
  article_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:data.Download.article)
}
inline void Download::set_article(int index, const char* value, size_t size) {
  article_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.Download.article)
}
inline ::std::string* Download::add_article() {
  return article_.Add();
}
inline void Download::add_article(const ::std::string& value) {
  article_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:data.Download.article)
}
inline void Download::add_article(const char* value) {
  article_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:data.Download.article)
}
inline void Download::add_article(const char* value, size_t size) {
  article_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:data.Download.article)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Download::article() const {
  // @@protoc_insertion_point(field_list:data.Download.article)
  return article_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Download::mutable_article() {
  // @@protoc_insertion_point(field_mutable_list:data.Download.article)
  return &article_;
}

// repeated string group = 2;
inline int Download::group_size() const {
  return group_.size();
}
inline void Download::clear_group() {
  group_.Clear();
}
inline const ::std::string& Download::group(int index) const {
  // @@protoc_insertion_point(field_get:data.Download.group)
  return group_.Get(index);
}
inline ::std::string* Download::mutable_group(int index) {
  // @@protoc_insertion_point(field_mutable:data.Download.group)
  return group_.Mutable(index);
}
inline void Download::set_group(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:data.Download.group)
  group_.Mutable(index)->assign(value);
}
inline void Download::set_group(int index, const char* value) {
  group_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:data.Download.group)
}
inline void Download::set_group(int index, const char* value, size_t size) {
  group_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.Download.group)
}
inline ::std::string* Download::add_group() {
  return group_.Add();
}
inline void Download::add_group(const ::std::string& value) {
  group_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:data.Download.group)
}
inline void Download::add_group(const char* value) {
  group_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:data.Download.group)
}
inline void Download::add_group(const char* value, size_t size) {
  group_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:data.Download.group)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Download::group() const {
  // @@protoc_insertion_point(field_list:data.Download.group)
  return group_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Download::mutable_group() {
  // @@protoc_insertion_point(field_mutable_list:data.Download.group)
  return &group_;
}

// required string path = 3;
inline bool Download::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Download::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Download::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Download::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Download::path() const {
  // @@protoc_insertion_point(field_get:data.Download.path)
  return *path_;
}
inline void Download::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:data.Download.path)
}
inline void Download::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.Download.path)
}
inline void Download::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.Download.path)
}
inline ::std::string* Download::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.Download.path)
  return path_;
}
inline ::std::string* Download::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Download::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.Download.path)
}

// required string name = 4;
inline bool Download::has_name() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Download::set_has_name() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Download::clear_has_name() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Download::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Download::name() const {
  // @@protoc_insertion_point(field_get:data.Download.name)
  return *name_;
}
inline void Download::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:data.Download.name)
}
inline void Download::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.Download.name)
}
inline void Download::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.Download.name)
}
inline ::std::string* Download::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.Download.name)
  return name_;
}
inline ::std::string* Download::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Download::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.Download.name)
}

// required string stash_name = 5;
inline bool Download::has_stash_name() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Download::set_has_stash_name() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Download::clear_has_stash_name() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Download::clear_stash_name() {
  if (stash_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stash_name_->clear();
  }
  clear_has_stash_name();
}
inline const ::std::string& Download::stash_name() const {
  // @@protoc_insertion_point(field_get:data.Download.stash_name)
  return *stash_name_;
}
inline void Download::set_stash_name(const ::std::string& value) {
  set_has_stash_name();
  if (stash_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stash_name_ = new ::std::string;
  }
  stash_name_->assign(value);
  // @@protoc_insertion_point(field_set:data.Download.stash_name)
}
inline void Download::set_stash_name(const char* value) {
  set_has_stash_name();
  if (stash_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stash_name_ = new ::std::string;
  }
  stash_name_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.Download.stash_name)
}
inline void Download::set_stash_name(const char* value, size_t size) {
  set_has_stash_name();
  if (stash_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stash_name_ = new ::std::string;
  }
  stash_name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.Download.stash_name)
}
inline ::std::string* Download::mutable_stash_name() {
  set_has_stash_name();
  if (stash_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    stash_name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.Download.stash_name)
  return stash_name_;
}
inline ::std::string* Download::release_stash_name() {
  clear_has_stash_name();
  if (stash_name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = stash_name_;
    stash_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Download::set_allocated_stash_name(::std::string* stash_name) {
  if (stash_name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete stash_name_;
  }
  if (stash_name) {
    set_has_stash_name();
    stash_name_ = stash_name;
  } else {
    clear_has_stash_name();
    stash_name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.Download.stash_name)
}

// required uint32 num_decode_jobs = 6;
inline bool Download::has_num_decode_jobs() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Download::set_has_num_decode_jobs() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Download::clear_has_num_decode_jobs() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Download::clear_num_decode_jobs() {
  num_decode_jobs_ = 0u;
  clear_has_num_decode_jobs();
}
inline ::google::protobuf::uint32 Download::num_decode_jobs() const {
  // @@protoc_insertion_point(field_get:data.Download.num_decode_jobs)
  return num_decode_jobs_;
}
inline void Download::set_num_decode_jobs(::google::protobuf::uint32 value) {
  set_has_num_decode_jobs();
  num_decode_jobs_ = value;
  // @@protoc_insertion_point(field_set:data.Download.num_decode_jobs)
}

// required uint32 num_actions_total = 7;
inline bool Download::has_num_actions_total() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Download::set_has_num_actions_total() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Download::clear_has_num_actions_total() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Download::clear_num_actions_total() {
  num_actions_total_ = 0u;
  clear_has_num_actions_total();
}
inline ::google::protobuf::uint32 Download::num_actions_total() const {
  // @@protoc_insertion_point(field_get:data.Download.num_actions_total)
  return num_actions_total_;
}
inline void Download::set_num_actions_total(::google::protobuf::uint32 value) {
  set_has_num_actions_total();
  num_actions_total_ = value;
  // @@protoc_insertion_point(field_set:data.Download.num_actions_total)
}

// required uint32 num_actions_ready = 8;
inline bool Download::has_num_actions_ready() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Download::set_has_num_actions_ready() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Download::clear_has_num_actions_ready() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Download::clear_num_actions_ready() {
  num_actions_ready_ = 0u;
  clear_has_num_actions_ready();
}
inline ::google::protobuf::uint32 Download::num_actions_ready() const {
  // @@protoc_insertion_point(field_get:data.Download.num_actions_ready)
  return num_actions_ready_;
}
inline void Download::set_num_actions_ready(::google::protobuf::uint32 value) {
  set_has_num_actions_ready();
  num_actions_ready_ = value;
  // @@protoc_insertion_point(field_set:data.Download.num_actions_ready)
}

// required uint32 errors = 9;
inline bool Download::has_errors() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Download::set_has_errors() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Download::clear_has_errors() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Download::clear_errors() {
  errors_ = 0u;
  clear_has_errors();
}
inline ::google::protobuf::uint32 Download::errors() const {
  // @@protoc_insertion_point(field_get:data.Download.errors)
  return errors_;
}
inline void Download::set_errors(::google::protobuf::uint32 value) {
  set_has_errors();
  errors_ = value;
  // @@protoc_insertion_point(field_set:data.Download.errors)
}

// repeated .data.File file = 10;
inline int Download::file_size() const {
  return file_.size();
}
inline void Download::clear_file() {
  file_.Clear();
}
inline const ::data::File& Download::file(int index) const {
  // @@protoc_insertion_point(field_get:data.Download.file)
  return file_.Get(index);
}
inline ::data::File* Download::mutable_file(int index) {
  // @@protoc_insertion_point(field_mutable:data.Download.file)
  return file_.Mutable(index);
}
inline ::data::File* Download::add_file() {
  // @@protoc_insertion_point(field_add:data.Download.file)
  return file_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::data::File >&
Download::file() const {
  // @@protoc_insertion_point(field_list:data.Download.file)
  return file_;
}
inline ::google::protobuf::RepeatedPtrField< ::data::File >*
Download::mutable_file() {
  // @@protoc_insertion_point(field_mutable_list:data.Download.file)
  return &file_;
}

// repeated .data.Stash stash = 11;
inline int Download::stash_size() const {
  return stash_.size();
}
inline void Download::clear_stash() {
  stash_.Clear();
}
inline const ::data::Stash& Download::stash(int index) const {
  // @@protoc_insertion_point(field_get:data.Download.stash)
  return stash_.Get(index);
}
inline ::data::Stash* Download::mutable_stash(int index) {
  // @@protoc_insertion_point(field_mutable:data.Download.stash)
  return stash_.Mutable(index);
}
inline ::data::Stash* Download::add_stash() {
  // @@protoc_insertion_point(field_add:data.Download.stash)
  return stash_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::data::Stash >&
Download::stash() const {
  // @@protoc_insertion_point(field_list:data.Download.stash)
  return stash_;
}
inline ::google::protobuf::RepeatedPtrField< ::data::Stash >*
Download::mutable_stash() {
  // @@protoc_insertion_point(field_mutable_list:data.Download.stash)
  return &stash_;
}

// -------------------------------------------------------------------

// TaskState

// required uint32 task_id = 1;
inline bool TaskState::has_task_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskState::set_has_task_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskState::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskState::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 TaskState::task_id() const {
  // @@protoc_insertion_point(field_get:data.TaskState.task_id)
  return task_id_;
}
inline void TaskState::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
  // @@protoc_insertion_point(field_set:data.TaskState.task_id)
}

// required uint32 account_id = 2;
inline bool TaskState::has_account_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskState::set_has_account_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskState::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskState::clear_account_id() {
  account_id_ = 0u;
  clear_has_account_id();
}
inline ::google::protobuf::uint32 TaskState::account_id() const {
  // @@protoc_insertion_point(field_get:data.TaskState.account_id)
  return account_id_;
}
inline void TaskState::set_account_id(::google::protobuf::uint32 value) {
  set_has_account_id();
  account_id_ = value;
  // @@protoc_insertion_point(field_set:data.TaskState.account_id)
}

// required uint32 batch_id = 3;
inline bool TaskState::has_batch_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskState::set_has_batch_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskState::clear_has_batch_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskState::clear_batch_id() {
  batch_id_ = 0u;
  clear_has_batch_id();
}
inline ::google::protobuf::uint32 TaskState::batch_id() const {
  // @@protoc_insertion_point(field_get:data.TaskState.batch_id)
  return batch_id_;
}
inline void TaskState::set_batch_id(::google::protobuf::uint32 value) {
  set_has_batch_id();
  batch_id_ = value;
  // @@protoc_insertion_point(field_set:data.TaskState.batch_id)
}

// required string desc = 4;
inline bool TaskState::has_desc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskState::set_has_desc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskState::clear_has_desc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskState::clear_desc() {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& TaskState::desc() const {
  // @@protoc_insertion_point(field_get:data.TaskState.desc)
  return *desc_;
}
inline void TaskState::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:data.TaskState.desc)
}
inline void TaskState::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.TaskState.desc)
}
inline void TaskState::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.TaskState.desc)
}
inline ::std::string* TaskState::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.TaskState.desc)
  return desc_;
}
inline ::std::string* TaskState::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TaskState::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.TaskState.desc)
}

// required string path = 5;
inline bool TaskState::has_path() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskState::set_has_path() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskState::clear_has_path() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskState::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& TaskState::path() const {
  // @@protoc_insertion_point(field_get:data.TaskState.path)
  return *path_;
}
inline void TaskState::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:data.TaskState.path)
}
inline void TaskState::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.TaskState.path)
}
inline void TaskState::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.TaskState.path)
}
inline ::std::string* TaskState::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.TaskState.path)
  return path_;
}
inline ::std::string* TaskState::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TaskState::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.TaskState.path)
}

// required uint64 size = 6;
inline bool TaskState::has_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskState::set_has_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskState::clear_has_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskState::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 TaskState::size() const {
  // @@protoc_insertion_point(field_get:data.TaskState.size)
  return size_;
}
inline void TaskState::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:data.TaskState.size)
}

// required uint32 type = 7;
inline bool TaskState::has_type() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TaskState::set_has_type() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TaskState::clear_has_type() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TaskState::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 TaskState::type() const {
  // @@protoc_insertion_point(field_get:data.TaskState.type)
  return type_;
}
inline void TaskState::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:data.TaskState.type)
}

// required uint32 state = 8;
inline bool TaskState::has_state() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TaskState::set_has_state() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TaskState::clear_has_state() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TaskState::clear_state() {
  state_ = 0u;
  clear_has_state();
}
inline ::google::protobuf::uint32 TaskState::state() const {
  // @@protoc_insertion_point(field_get:data.TaskState.state)
  return state_;
}
inline void TaskState::set_state(::google::protobuf::uint32 value) {
  set_has_state();
  state_ = value;
  // @@protoc_insertion_point(field_set:data.TaskState.state)
}

// required uint32 errors = 9;
inline bool TaskState::has_errors() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TaskState::set_has_errors() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TaskState::clear_has_errors() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TaskState::clear_errors() {
  errors_ = 0u;
  clear_has_errors();
}
inline ::google::protobuf::uint32 TaskState::errors() const {
  // @@protoc_insertion_point(field_get:data.TaskState.errors)
  return errors_;
}
inline void TaskState::set_errors(::google::protobuf::uint32 value) {
  set_has_errors();
  errors_ = value;
  // @@protoc_insertion_point(field_set:data.TaskState.errors)
}

// required uint32 runtime = 10;
inline bool TaskState::has_runtime() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TaskState::set_has_runtime() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TaskState::clear_has_runtime() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TaskState::clear_runtime() {
  runtime_ = 0u;
  clear_has_runtime();
}
inline ::google::protobuf::uint32 TaskState::runtime() const {
  // @@protoc_insertion_point(field_get:data.TaskState.runtime)
  return runtime_;
}
inline void TaskState::set_runtime(::google::protobuf::uint32 value) {
  set_has_runtime();
  runtime_ = value;
  // @@protoc_insertion_point(field_set:data.TaskState.runtime)
}

// required bytes data = 11;
inline bool TaskState::has_data() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TaskState::set_has_data() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TaskState::clear_has_data() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TaskState::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& TaskState::data() const {
  // @@protoc_insertion_point(field_get:data.TaskState.data)
  return *data_;
}
inline void TaskState::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:data.TaskState.data)
}
inline void TaskState::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.TaskState.data)
}
inline void TaskState::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.TaskState.data)
}
inline ::std::string* TaskState::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.TaskState.data)
  return data_;
}
inline ::std::string* TaskState::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TaskState::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.TaskState.data)
}

// -------------------------------------------------------------------

// Batch

// required uint32 account_id = 1;
inline bool Batch::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Batch::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Batch::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Batch::clear_account_id() {
  account_id_ = 0u;
  clear_has_account_id();
}
inline ::google::protobuf::uint32 Batch::account_id() const {
  // @@protoc_insertion_point(field_get:data.Batch.account_id)
  return account_id_;
}
inline void Batch::set_account_id(::google::protobuf::uint32 value) {
  set_has_account_id();
  account_id_ = value;
  // @@protoc_insertion_point(field_set:data.Batch.account_id)
}

// required uint32 batch_id = 2;
inline bool Batch::has_batch_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Batch::set_has_batch_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Batch::clear_has_batch_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Batch::clear_batch_id() {
  batch_id_ = 0u;
  clear_has_batch_id();
}
inline ::google::protobuf::uint32 Batch::batch_id() const {
  // @@protoc_insertion_point(field_get:data.Batch.batch_id)
  return batch_id_;
}
inline void Batch::set_batch_id(::google::protobuf::uint32 value) {
  set_has_batch_id();
  batch_id_ = value;
  // @@protoc_insertion_point(field_set:data.Batch.batch_id)
}

// required string path = 3;
inline bool Batch::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Batch::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Batch::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Batch::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Batch::path() const {
  // @@protoc_insertion_point(field_get:data.Batch.path)
  return *path_;
}
inline void Batch::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:data.Batch.path)
}
inline void Batch::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.Batch.path)
}
inline void Batch::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.Batch.path)
}
inline ::std::string* Batch::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.Batch.path)
  return path_;
}
inline ::std::string* Batch::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Batch::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.Batch.path)
}

// required string desc = 4;
inline bool Batch::has_desc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Batch::set_has_desc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Batch::clear_has_desc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Batch::clear_desc() {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& Batch::desc() const {
  // @@protoc_insertion_point(field_get:data.Batch.desc)
  return *desc_;
}
inline void Batch::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:data.Batch.desc)
}
inline void Batch::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.Batch.desc)
}
inline void Batch::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.Batch.desc)
}
inline ::std::string* Batch::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.Batch.desc)
  return desc_;
}
inline ::std::string* Batch::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Batch::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.Batch.desc)
}

// required uint64 byte_size = 5;
inline bool Batch::has_byte_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Batch::set_has_byte_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Batch::clear_has_byte_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Batch::clear_byte_size() {
  byte_size_ = GOOGLE_ULONGLONG(0);
  clear_has_byte_size();
}
inline ::google::protobuf::uint64 Batch::byte_size() const {
  // @@protoc_insertion_point(field_get:data.Batch.byte_size)
  return byte_size_;
}
inline void Batch::set_byte_size(::google::protobuf::uint64 value) {
  set_has_byte_size();
  byte_size_ = value;
  // @@protoc_insertion_point(field_set:data.Batch.byte_size)
}

// required uint32 num_tasks = 6;
inline bool Batch::has_num_tasks() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Batch::set_has_num_tasks() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Batch::clear_has_num_tasks() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Batch::clear_num_tasks() {
  num_tasks_ = 0u;
  clear_has_num_tasks();
}
inline ::google::protobuf::uint32 Batch::num_tasks() const {
  // @@protoc_insertion_point(field_get:data.Batch.num_tasks)
  return num_tasks_;
}
inline void Batch::set_num_tasks(::google::protobuf::uint32 value) {
  set_has_num_tasks();
  num_tasks_ = value;
  // @@protoc_insertion_point(field_set:data.Batch.num_tasks)
}

// required uint32 num_files = 7;
inline bool Batch::has_num_files() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Batch::set_has_num_files() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Batch::clear_has_num_files() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Batch::clear_num_files() {
  num_files_ = 0u;
  clear_has_num_files();
}
inline ::google::protobuf::uint32 Batch::num_files() const {
  // @@protoc_insertion_point(field_get:data.Batch.num_files)
  return num_files_;
}
inline void Batch::set_num_files(::google::protobuf::uint32 value) {
  set_has_num_files();
  num_files_ = value;
  // @@protoc_insertion_point(field_set:data.Batch.num_files)
}

// required bool damaged = 8;
inline bool Batch::has_damaged() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Batch::set_has_damaged() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Batch::clear_has_damaged() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Batch::clear_damaged() {
  damaged_ = false;
  clear_has_damaged();
}
inline bool Batch::damaged() const {
  // @@protoc_insertion_point(field_get:data.Batch.damaged)
  return damaged_;
}
inline void Batch::set_damaged(bool value) {
  set_has_damaged();
  damaged_ = value;
  // @@protoc_insertion_point(field_set:data.Batch.damaged)
}

// required float completion = 9;
inline bool Batch::has_completion() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Batch::set_has_completion() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Batch::clear_has_completion() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Batch::clear_completion() {
  completion_ = 0;
  clear_has_completion();
}
inline float Batch::completion() const {
  // @@protoc_insertion_point(field_get:data.Batch.completion)
  return completion_;
}
inline void Batch::set_completion(float value) {
  set_has_completion();
  completion_ = value;
  // @@protoc_insertion_point(field_set:data.Batch.completion)
}

// required uint32 type = 10;
inline bool Batch::has_type() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Batch::set_has_type() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Batch::clear_has_type() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Batch::clear_type() {
  type_ = 0u;
  clear_has_type();
}
inline ::google::protobuf::uint32 Batch::type() const {
  // @@protoc_insertion_point(field_get:data.Batch.type)
  return type_;
}
inline void Batch::set_type(::google::protobuf::uint32 value) {
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:data.Batch.type)
}

// required uint32 runtime = 11;
inline bool Batch::has_runtime() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Batch::set_has_runtime() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Batch::clear_has_runtime() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Batch::clear_runtime() {
  runtime_ = 0u;
  clear_has_runtime();
}
inline ::google::protobuf::uint32 Batch::runtime() const {
  // @@protoc_insertion_point(field_get:data.Batch.runtime)
  return runtime_;
}
inline void Batch::set_runtime(::google::protobuf::uint32 value) {
  set_has_runtime();
  runtime_ = value;
  // @@protoc_insertion_point(field_set:data.Batch.runtime)
}

// -------------------------------------------------------------------

// TaskList

// required uint64 bytes_queued = 1;
inline bool TaskList::has_bytes_queued() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskList::set_has_bytes_queued() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskList::clear_has_bytes_queued() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskList::clear_bytes_queued() {
  bytes_queued_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_queued();
}
inline ::google::protobuf::uint64 TaskList::bytes_queued() const {
  // @@protoc_insertion_point(field_get:data.TaskList.bytes_queued)
  return bytes_queued_;
}
inline void TaskList::set_bytes_queued(::google::protobuf::uint64 value) {
  set_has_bytes_queued();
  bytes_queued_ = value;
  // @@protoc_insertion_point(field_set:data.TaskList.bytes_queued)
}

// required uint64 bytes_ready = 2;
inline bool TaskList::has_bytes_ready() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskList::set_has_bytes_ready() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskList::clear_has_bytes_ready() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskList::clear_bytes_ready() {
  bytes_ready_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_ready();
}
inline ::google::protobuf::uint64 TaskList::bytes_ready() const {
  // @@protoc_insertion_point(field_get:data.TaskList.bytes_ready)
  return bytes_ready_;
}
inline void TaskList::set_bytes_ready(::google::protobuf::uint64 value) {
  set_has_bytes_ready();
  bytes_ready_ = value;
  // @@protoc_insertion_point(field_set:data.TaskList.bytes_ready)
}

// required uint64 object_id = 3;
inline bool TaskList::has_object_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskList::set_has_object_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskList::clear_has_object_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskList::clear_object_id() {
  object_id_ = GOOGLE_ULONGLONG(0);
  clear_has_object_id();
}
inline ::google::protobuf::uint64 TaskList::object_id() const {
  // @@protoc_insertion_point(field_get:data.TaskList.object_id)
  return object_id_;
}
inline void TaskList::set_object_id(::google::protobuf::uint64 value) {
  set_has_object_id();
  object_id_ = value;
  // @@protoc_insertion_point(field_set:data.TaskList.object_id)
}

// repeated .data.Batch batch = 4;
inline int TaskList::batch_size() const {
  return batch_.size();
}
inline void TaskList::clear_batch() {
  batch_.Clear();
}
inline const ::data::Batch& TaskList::batch(int index) const {
  // @@protoc_insertion_point(field_get:data.TaskList.batch)
  return batch_.Get(index);
}
inline ::data::Batch* TaskList::mutable_batch(int index) {
  // @@protoc_insertion_point(field_mutable:data.TaskList.batch)
  return batch_.Mutable(index);
}
inline ::data::Batch* TaskList::add_batch() {
  // @@protoc_insertion_point(field_add:data.TaskList.batch)
  return batch_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::data::Batch >&
TaskList::batch() const {
  // @@protoc_insertion_point(field_list:data.TaskList.batch)
  return batch_;
}
inline ::google::protobuf::RepeatedPtrField< ::data::Batch >*
TaskList::mutable_batch() {
  // @@protoc_insertion_point(field_mutable_list:data.TaskList.batch)
  return &batch_;
}

// repeated .data.TaskState tasks = 5;
inline int TaskList::tasks_size() const {
  return tasks_.size();
}
inline void TaskList::clear_tasks() {
  tasks_.Clear();
}
inline const ::data::TaskState& TaskList::tasks(int index) const {
  // @@protoc_insertion_point(field_get:data.TaskList.tasks)
  return tasks_.Get(index);
}
inline ::data::TaskState* TaskList::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:data.TaskList.tasks)
  return tasks_.Mutable(index);
}
inline ::data::TaskState* TaskList::add_tasks() {
  // @@protoc_insertion_point(field_add:data.TaskList.tasks)
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::data::TaskState >&
TaskList::tasks() const {
  // @@protoc_insertion_point(field_list:data.TaskList.tasks)
  return tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::data::TaskState >*
TaskList::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:data.TaskList.tasks)
  return &tasks_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace data

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_engine_2eproto__INCLUDED

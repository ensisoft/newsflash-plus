// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: engine.proto

#ifndef PROTOBUF_engine_2eproto__INCLUDED
#define PROTOBUF_engine_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace data {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_engine_2eproto();
void protobuf_AssignDesc_engine_2eproto();
void protobuf_ShutdownFile_engine_2eproto();

class Account;
class File;
class Stash;
class Download;
class TaskState;
class Batch;
class TaskList;

// ===================================================================

class Account : public ::google::protobuf::Message {
 public:
  Account();
  virtual ~Account();

  Account(const Account& from);

  inline Account& operator=(const Account& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Account& default_instance();

  void Swap(Account* other);

  // implements Message ----------------------------------------------

  Account* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Account& from);
  void MergeFrom(const Account& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // required string user = 3;
  inline bool has_user() const;
  inline void clear_user();
  static const int kUserFieldNumber = 3;
  inline const ::std::string& user() const;
  inline void set_user(const ::std::string& value);
  inline void set_user(const char* value);
  inline void set_user(const char* value, size_t size);
  inline ::std::string* mutable_user();
  inline ::std::string* release_user();
  inline void set_allocated_user(::std::string* user);

  // required string pass = 4;
  inline bool has_pass() const;
  inline void clear_pass();
  static const int kPassFieldNumber = 4;
  inline const ::std::string& pass() const;
  inline void set_pass(const ::std::string& value);
  inline void set_pass(const char* value);
  inline void set_pass(const char* value, size_t size);
  inline ::std::string* mutable_pass();
  inline ::std::string* release_pass();
  inline void set_allocated_pass(::std::string* pass);

  // required string secure_host = 5;
  inline bool has_secure_host() const;
  inline void clear_secure_host();
  static const int kSecureHostFieldNumber = 5;
  inline const ::std::string& secure_host() const;
  inline void set_secure_host(const ::std::string& value);
  inline void set_secure_host(const char* value);
  inline void set_secure_host(const char* value, size_t size);
  inline ::std::string* mutable_secure_host();
  inline ::std::string* release_secure_host();
  inline void set_allocated_secure_host(::std::string* secure_host);

  // required uint32 secure_port = 6;
  inline bool has_secure_port() const;
  inline void clear_secure_port();
  static const int kSecurePortFieldNumber = 6;
  inline ::google::protobuf::uint32 secure_port() const;
  inline void set_secure_port(::google::protobuf::uint32 value);

  // required string general_host = 7;
  inline bool has_general_host() const;
  inline void clear_general_host();
  static const int kGeneralHostFieldNumber = 7;
  inline const ::std::string& general_host() const;
  inline void set_general_host(const ::std::string& value);
  inline void set_general_host(const char* value);
  inline void set_general_host(const char* value, size_t size);
  inline ::std::string* mutable_general_host();
  inline ::std::string* release_general_host();
  inline void set_allocated_general_host(::std::string* general_host);

  // required uint32 general_port = 8;
  inline bool has_general_port() const;
  inline void clear_general_port();
  static const int kGeneralPortFieldNumber = 8;
  inline ::google::protobuf::uint32 general_port() const;
  inline void set_general_port(::google::protobuf::uint32 value);

  // required uint32 max_connections = 9;
  inline bool has_max_connections() const;
  inline void clear_max_connections();
  static const int kMaxConnectionsFieldNumber = 9;
  inline ::google::protobuf::uint32 max_connections() const;
  inline void set_max_connections(::google::protobuf::uint32 value);

  // required bool enable_secure_server = 10;
  inline bool has_enable_secure_server() const;
  inline void clear_enable_secure_server();
  static const int kEnableSecureServerFieldNumber = 10;
  inline bool enable_secure_server() const;
  inline void set_enable_secure_server(bool value);

  // required bool enable_general_server = 11;
  inline bool has_enable_general_server() const;
  inline void clear_enable_general_server();
  static const int kEnableGeneralServerFieldNumber = 11;
  inline bool enable_general_server() const;
  inline void set_enable_general_server(bool value);

  // required bool enable_pipelining = 12;
  inline bool has_enable_pipelining() const;
  inline void clear_enable_pipelining();
  static const int kEnablePipeliningFieldNumber = 12;
  inline bool enable_pipelining() const;
  inline void set_enable_pipelining(bool value);

  // required bool enable_compression = 13;
  inline bool has_enable_compression() const;
  inline void clear_enable_compression();
  static const int kEnableCompressionFieldNumber = 13;
  inline bool enable_compression() const;
  inline void set_enable_compression(bool value);

  // @@protoc_insertion_point(class_scope:data.Account)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_user();
  inline void clear_has_user();
  inline void set_has_pass();
  inline void clear_has_pass();
  inline void set_has_secure_host();
  inline void clear_has_secure_host();
  inline void set_has_secure_port();
  inline void clear_has_secure_port();
  inline void set_has_general_host();
  inline void clear_has_general_host();
  inline void set_has_general_port();
  inline void clear_has_general_port();
  inline void set_has_max_connections();
  inline void clear_has_max_connections();
  inline void set_has_enable_secure_server();
  inline void clear_has_enable_secure_server();
  inline void set_has_enable_general_server();
  inline void clear_has_enable_general_server();
  inline void set_has_enable_pipelining();
  inline void clear_has_enable_pipelining();
  inline void set_has_enable_compression();
  inline void clear_has_enable_compression();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* name_;
  ::std::string* user_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::uint32 secure_port_;
  ::std::string* pass_;
  ::std::string* secure_host_;
  ::std::string* general_host_;
  ::google::protobuf::uint32 general_port_;
  ::google::protobuf::uint32 max_connections_;
  bool enable_secure_server_;
  bool enable_general_server_;
  bool enable_pipelining_;
  bool enable_compression_;
  friend void  protobuf_AddDesc_engine_2eproto();
  friend void protobuf_AssignDesc_engine_2eproto();
  friend void protobuf_ShutdownFile_engine_2eproto();

  void InitAsDefaultInstance();
  static Account* default_instance_;
};
// -------------------------------------------------------------------

class File : public ::google::protobuf::Message {
 public:
  File();
  virtual ~File();

  File(const File& from);

  inline File& operator=(const File& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const File& default_instance();

  void Swap(File* other);

  // implements Message ----------------------------------------------

  File* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const File& from);
  void MergeFrom(const File& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string filename = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFilenameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // required string filepath = 2;
  inline bool has_filepath() const;
  inline void clear_filepath();
  static const int kFilepathFieldNumber = 2;
  inline const ::std::string& filepath() const;
  inline void set_filepath(const ::std::string& value);
  inline void set_filepath(const char* value);
  inline void set_filepath(const char* value, size_t size);
  inline ::std::string* mutable_filepath();
  inline ::std::string* release_filepath();
  inline void set_allocated_filepath(::std::string* filepath);

  // required string dataname = 3;
  inline bool has_dataname() const;
  inline void clear_dataname();
  static const int kDatanameFieldNumber = 3;
  inline const ::std::string& dataname() const;
  inline void set_dataname(const ::std::string& value);
  inline void set_dataname(const char* value);
  inline void set_dataname(const char* value, size_t size);
  inline ::std::string* mutable_dataname();
  inline ::std::string* release_dataname();
  inline void set_allocated_dataname(::std::string* dataname);

  // required bool is_binary = 4;
  inline bool has_is_binary() const;
  inline void clear_is_binary();
  static const int kIsBinaryFieldNumber = 4;
  inline bool is_binary() const;
  inline void set_is_binary(bool value);

  // @@protoc_insertion_point(class_scope:data.File)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_filepath();
  inline void clear_has_filepath();
  inline void set_has_dataname();
  inline void clear_has_dataname();
  inline void set_has_is_binary();
  inline void clear_has_is_binary();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* filename_;
  ::std::string* filepath_;
  ::std::string* dataname_;
  bool is_binary_;
  friend void  protobuf_AddDesc_engine_2eproto();
  friend void protobuf_AssignDesc_engine_2eproto();
  friend void protobuf_ShutdownFile_engine_2eproto();

  void InitAsDefaultInstance();
  static File* default_instance_;
};
// -------------------------------------------------------------------

class Stash : public ::google::protobuf::Message {
 public:
  Stash();
  virtual ~Stash();

  Stash(const Stash& from);

  inline Stash& operator=(const Stash& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Stash& default_instance();

  void Swap(Stash* other);

  // implements Message ----------------------------------------------

  Stash* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Stash& from);
  void MergeFrom(const Stash& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 sequence = 1;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 1;
  inline ::google::protobuf::uint32 sequence() const;
  inline void set_sequence(::google::protobuf::uint32 value);

  // required bytes data = 2;
  inline bool has_data() const;
  inline void clear_data();
  static const int kDataFieldNumber = 2;
  inline const ::std::string& data() const;
  inline void set_data(const ::std::string& value);
  inline void set_data(const char* value);
  inline void set_data(const void* value, size_t size);
  inline ::std::string* mutable_data();
  inline ::std::string* release_data();
  inline void set_allocated_data(::std::string* data);

  // @@protoc_insertion_point(class_scope:data.Stash)
 private:
  inline void set_has_sequence();
  inline void clear_has_sequence();
  inline void set_has_data();
  inline void clear_has_data();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* data_;
  ::google::protobuf::uint32 sequence_;
  friend void  protobuf_AddDesc_engine_2eproto();
  friend void protobuf_AssignDesc_engine_2eproto();
  friend void protobuf_ShutdownFile_engine_2eproto();

  void InitAsDefaultInstance();
  static Stash* default_instance_;
};
// -------------------------------------------------------------------

class Download : public ::google::protobuf::Message {
 public:
  Download();
  virtual ~Download();

  Download(const Download& from);

  inline Download& operator=(const Download& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Download& default_instance();

  void Swap(Download* other);

  // implements Message ----------------------------------------------

  Download* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Download& from);
  void MergeFrom(const Download& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated string article = 1;
  inline int article_size() const;
  inline void clear_article();
  static const int kArticleFieldNumber = 1;
  inline const ::std::string& article(int index) const;
  inline ::std::string* mutable_article(int index);
  inline void set_article(int index, const ::std::string& value);
  inline void set_article(int index, const char* value);
  inline void set_article(int index, const char* value, size_t size);
  inline ::std::string* add_article();
  inline void add_article(const ::std::string& value);
  inline void add_article(const char* value);
  inline void add_article(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& article() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_article();

  // repeated string group = 2;
  inline int group_size() const;
  inline void clear_group();
  static const int kGroupFieldNumber = 2;
  inline const ::std::string& group(int index) const;
  inline ::std::string* mutable_group(int index);
  inline void set_group(int index, const ::std::string& value);
  inline void set_group(int index, const char* value);
  inline void set_group(int index, const char* value, size_t size);
  inline ::std::string* add_group();
  inline void add_group(const ::std::string& value);
  inline void add_group(const char* value);
  inline void add_group(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& group() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_group();

  // required uint32 num_decode_jobs = 3;
  inline bool has_num_decode_jobs() const;
  inline void clear_num_decode_jobs();
  static const int kNumDecodeJobsFieldNumber = 3;
  inline ::google::protobuf::uint32 num_decode_jobs() const;
  inline void set_num_decode_jobs(::google::protobuf::uint32 value);

  // required uint32 num_actions_total = 4;
  inline bool has_num_actions_total() const;
  inline void clear_num_actions_total();
  static const int kNumActionsTotalFieldNumber = 4;
  inline ::google::protobuf::uint32 num_actions_total() const;
  inline void set_num_actions_total(::google::protobuf::uint32 value);

  // required uint32 num_actions_ready = 5;
  inline bool has_num_actions_ready() const;
  inline void clear_num_actions_ready();
  static const int kNumActionsReadyFieldNumber = 5;
  inline ::google::protobuf::uint32 num_actions_ready() const;
  inline void set_num_actions_ready(::google::protobuf::uint32 value);

  // repeated .data.File file = 6;
  inline int file_size() const;
  inline void clear_file();
  static const int kFileFieldNumber = 6;
  inline const ::data::File& file(int index) const;
  inline ::data::File* mutable_file(int index);
  inline ::data::File* add_file();
  inline const ::google::protobuf::RepeatedPtrField< ::data::File >&
      file() const;
  inline ::google::protobuf::RepeatedPtrField< ::data::File >*
      mutable_file();

  // repeated .data.Stash stash = 7;
  inline int stash_size() const;
  inline void clear_stash();
  static const int kStashFieldNumber = 7;
  inline const ::data::Stash& stash(int index) const;
  inline ::data::Stash* mutable_stash(int index);
  inline ::data::Stash* add_stash();
  inline const ::google::protobuf::RepeatedPtrField< ::data::Stash >&
      stash() const;
  inline ::google::protobuf::RepeatedPtrField< ::data::Stash >*
      mutable_stash();

  // @@protoc_insertion_point(class_scope:data.Download)
 private:
  inline void set_has_num_decode_jobs();
  inline void clear_has_num_decode_jobs();
  inline void set_has_num_actions_total();
  inline void clear_has_num_actions_total();
  inline void set_has_num_actions_ready();
  inline void clear_has_num_actions_ready();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::std::string> article_;
  ::google::protobuf::RepeatedPtrField< ::std::string> group_;
  ::google::protobuf::uint32 num_decode_jobs_;
  ::google::protobuf::uint32 num_actions_total_;
  ::google::protobuf::RepeatedPtrField< ::data::File > file_;
  ::google::protobuf::RepeatedPtrField< ::data::Stash > stash_;
  ::google::protobuf::uint32 num_actions_ready_;
  friend void  protobuf_AddDesc_engine_2eproto();
  friend void protobuf_AssignDesc_engine_2eproto();
  friend void protobuf_ShutdownFile_engine_2eproto();

  void InitAsDefaultInstance();
  static Download* default_instance_;
};
// -------------------------------------------------------------------

class TaskState : public ::google::protobuf::Message {
 public:
  TaskState();
  virtual ~TaskState();

  TaskState(const TaskState& from);

  inline TaskState& operator=(const TaskState& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskState& default_instance();

  void Swap(TaskState* other);

  // implements Message ----------------------------------------------

  TaskState* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskState& from);
  void MergeFrom(const TaskState& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline ::google::protobuf::uint32 account_id() const;
  inline void set_account_id(::google::protobuf::uint32 value);

  // required uint32 batch_id = 2;
  inline bool has_batch_id() const;
  inline void clear_batch_id();
  static const int kBatchIdFieldNumber = 2;
  inline ::google::protobuf::uint32 batch_id() const;
  inline void set_batch_id(::google::protobuf::uint32 value);

  // required uint32 task_id = 3;
  inline bool has_task_id() const;
  inline void clear_task_id();
  static const int kTaskIdFieldNumber = 3;
  inline ::google::protobuf::uint32 task_id() const;
  inline void set_task_id(::google::protobuf::uint32 value);

  // required string desc = 4;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 4;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // required string path = 5;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 5;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required uint64 size = 6;
  inline bool has_size() const;
  inline void clear_size();
  static const int kSizeFieldNumber = 6;
  inline ::google::protobuf::uint64 size() const;
  inline void set_size(::google::protobuf::uint64 value);

  // optional .data.Download download = 7;
  inline bool has_download() const;
  inline void clear_download();
  static const int kDownloadFieldNumber = 7;
  inline const ::data::Download& download() const;
  inline ::data::Download* mutable_download();
  inline ::data::Download* release_download();
  inline void set_allocated_download(::data::Download* download);

  // @@protoc_insertion_point(class_scope:data.TaskState)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_batch_id();
  inline void clear_has_batch_id();
  inline void set_has_task_id();
  inline void clear_has_task_id();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_size();
  inline void clear_has_size();
  inline void set_has_download();
  inline void clear_has_download();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 account_id_;
  ::google::protobuf::uint32 batch_id_;
  ::std::string* desc_;
  ::std::string* path_;
  ::google::protobuf::uint64 size_;
  ::data::Download* download_;
  ::google::protobuf::uint32 task_id_;
  friend void  protobuf_AddDesc_engine_2eproto();
  friend void protobuf_AssignDesc_engine_2eproto();
  friend void protobuf_ShutdownFile_engine_2eproto();

  void InitAsDefaultInstance();
  static TaskState* default_instance_;
};
// -------------------------------------------------------------------

class Batch : public ::google::protobuf::Message {
 public:
  Batch();
  virtual ~Batch();

  Batch(const Batch& from);

  inline Batch& operator=(const Batch& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Batch& default_instance();

  void Swap(Batch* other);

  // implements Message ----------------------------------------------

  Batch* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Batch& from);
  void MergeFrom(const Batch& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 account_id = 1;
  inline bool has_account_id() const;
  inline void clear_account_id();
  static const int kAccountIdFieldNumber = 1;
  inline ::google::protobuf::uint32 account_id() const;
  inline void set_account_id(::google::protobuf::uint32 value);

  // required uint32 batch_id = 2;
  inline bool has_batch_id() const;
  inline void clear_batch_id();
  static const int kBatchIdFieldNumber = 2;
  inline ::google::protobuf::uint32 batch_id() const;
  inline void set_batch_id(::google::protobuf::uint32 value);

  // required string path = 3;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 3;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // required string desc = 4;
  inline bool has_desc() const;
  inline void clear_desc();
  static const int kDescFieldNumber = 4;
  inline const ::std::string& desc() const;
  inline void set_desc(const ::std::string& value);
  inline void set_desc(const char* value);
  inline void set_desc(const char* value, size_t size);
  inline ::std::string* mutable_desc();
  inline ::std::string* release_desc();
  inline void set_allocated_desc(::std::string* desc);

  // required uint64 byte_size = 5;
  inline bool has_byte_size() const;
  inline void clear_byte_size();
  static const int kByteSizeFieldNumber = 5;
  inline ::google::protobuf::uint64 byte_size() const;
  inline void set_byte_size(::google::protobuf::uint64 value);

  // required uint32 num_tasks = 6;
  inline bool has_num_tasks() const;
  inline void clear_num_tasks();
  static const int kNumTasksFieldNumber = 6;
  inline ::google::protobuf::uint32 num_tasks() const;
  inline void set_num_tasks(::google::protobuf::uint32 value);

  // required uint32 num_slices = 7;
  inline bool has_num_slices() const;
  inline void clear_num_slices();
  static const int kNumSlicesFieldNumber = 7;
  inline ::google::protobuf::uint32 num_slices() const;
  inline void set_num_slices(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:data.Batch)
 private:
  inline void set_has_account_id();
  inline void clear_has_account_id();
  inline void set_has_batch_id();
  inline void clear_has_batch_id();
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_desc();
  inline void clear_has_desc();
  inline void set_has_byte_size();
  inline void clear_has_byte_size();
  inline void set_has_num_tasks();
  inline void clear_has_num_tasks();
  inline void set_has_num_slices();
  inline void clear_has_num_slices();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 account_id_;
  ::google::protobuf::uint32 batch_id_;
  ::std::string* path_;
  ::std::string* desc_;
  ::google::protobuf::uint64 byte_size_;
  ::google::protobuf::uint32 num_tasks_;
  ::google::protobuf::uint32 num_slices_;
  friend void  protobuf_AddDesc_engine_2eproto();
  friend void protobuf_AssignDesc_engine_2eproto();
  friend void protobuf_ShutdownFile_engine_2eproto();

  void InitAsDefaultInstance();
  static Batch* default_instance_;
};
// -------------------------------------------------------------------

class TaskList : public ::google::protobuf::Message {
 public:
  TaskList();
  virtual ~TaskList();

  TaskList(const TaskList& from);

  inline TaskList& operator=(const TaskList& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TaskList& default_instance();

  void Swap(TaskList* other);

  // implements Message ----------------------------------------------

  TaskList* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TaskList& from);
  void MergeFrom(const TaskList& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 current_id = 1;
  inline bool has_current_id() const;
  inline void clear_current_id();
  static const int kCurrentIdFieldNumber = 1;
  inline ::google::protobuf::uint32 current_id() const;
  inline void set_current_id(::google::protobuf::uint32 value);

  // required uint64 bytes_queued = 2;
  inline bool has_bytes_queued() const;
  inline void clear_bytes_queued();
  static const int kBytesQueuedFieldNumber = 2;
  inline ::google::protobuf::uint64 bytes_queued() const;
  inline void set_bytes_queued(::google::protobuf::uint64 value);

  // required uint64 bytes_ready = 3;
  inline bool has_bytes_ready() const;
  inline void clear_bytes_ready();
  static const int kBytesReadyFieldNumber = 3;
  inline ::google::protobuf::uint64 bytes_ready() const;
  inline void set_bytes_ready(::google::protobuf::uint64 value);

  // repeated .data.Account account = 4;
  inline int account_size() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 4;
  inline const ::data::Account& account(int index) const;
  inline ::data::Account* mutable_account(int index);
  inline ::data::Account* add_account();
  inline const ::google::protobuf::RepeatedPtrField< ::data::Account >&
      account() const;
  inline ::google::protobuf::RepeatedPtrField< ::data::Account >*
      mutable_account();

  // repeated .data.Batch batch = 5;
  inline int batch_size() const;
  inline void clear_batch();
  static const int kBatchFieldNumber = 5;
  inline const ::data::Batch& batch(int index) const;
  inline ::data::Batch* mutable_batch(int index);
  inline ::data::Batch* add_batch();
  inline const ::google::protobuf::RepeatedPtrField< ::data::Batch >&
      batch() const;
  inline ::google::protobuf::RepeatedPtrField< ::data::Batch >*
      mutable_batch();

  // repeated .data.TaskState tasks = 6;
  inline int tasks_size() const;
  inline void clear_tasks();
  static const int kTasksFieldNumber = 6;
  inline const ::data::TaskState& tasks(int index) const;
  inline ::data::TaskState* mutable_tasks(int index);
  inline ::data::TaskState* add_tasks();
  inline const ::google::protobuf::RepeatedPtrField< ::data::TaskState >&
      tasks() const;
  inline ::google::protobuf::RepeatedPtrField< ::data::TaskState >*
      mutable_tasks();

  // @@protoc_insertion_point(class_scope:data.TaskList)
 private:
  inline void set_has_current_id();
  inline void clear_has_current_id();
  inline void set_has_bytes_queued();
  inline void clear_has_bytes_queued();
  inline void set_has_bytes_ready();
  inline void clear_has_bytes_ready();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 bytes_queued_;
  ::google::protobuf::uint64 bytes_ready_;
  ::google::protobuf::RepeatedPtrField< ::data::Account > account_;
  ::google::protobuf::RepeatedPtrField< ::data::Batch > batch_;
  ::google::protobuf::RepeatedPtrField< ::data::TaskState > tasks_;
  ::google::protobuf::uint32 current_id_;
  friend void  protobuf_AddDesc_engine_2eproto();
  friend void protobuf_AssignDesc_engine_2eproto();
  friend void protobuf_ShutdownFile_engine_2eproto();

  void InitAsDefaultInstance();
  static TaskList* default_instance_;
};
// ===================================================================


// ===================================================================

// Account

// required uint32 id = 1;
inline bool Account::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Account::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Account::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Account::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 Account::id() const {
  // @@protoc_insertion_point(field_get:data.Account.id)
  return id_;
}
inline void Account::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:data.Account.id)
}

// required string name = 2;
inline bool Account::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Account::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Account::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Account::clear_name() {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& Account::name() const {
  // @@protoc_insertion_point(field_get:data.Account.name)
  return *name_;
}
inline void Account::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set:data.Account.name)
}
inline void Account::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.Account.name)
}
inline void Account::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.Account.name)
}
inline ::std::string* Account::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    name_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.Account.name)
  return name_;
}
inline ::std::string* Account::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Account::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.Account.name)
}

// required string user = 3;
inline bool Account::has_user() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Account::set_has_user() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Account::clear_has_user() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Account::clear_user() {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_->clear();
  }
  clear_has_user();
}
inline const ::std::string& Account::user() const {
  // @@protoc_insertion_point(field_get:data.Account.user)
  return *user_;
}
inline void Account::set_user(const ::std::string& value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set:data.Account.user)
}
inline void Account::set_user(const char* value) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.Account.user)
}
inline void Account::set_user(const char* value, size_t size) {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  user_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.Account.user)
}
inline ::std::string* Account::mutable_user() {
  set_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    user_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.Account.user)
  return user_;
}
inline ::std::string* Account::release_user() {
  clear_has_user();
  if (user_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = user_;
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Account::set_allocated_user(::std::string* user) {
  if (user_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete user_;
  }
  if (user) {
    set_has_user();
    user_ = user;
  } else {
    clear_has_user();
    user_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.Account.user)
}

// required string pass = 4;
inline bool Account::has_pass() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Account::set_has_pass() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Account::clear_has_pass() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Account::clear_pass() {
  if (pass_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_->clear();
  }
  clear_has_pass();
}
inline const ::std::string& Account::pass() const {
  // @@protoc_insertion_point(field_get:data.Account.pass)
  return *pass_;
}
inline void Account::set_pass(const ::std::string& value) {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_ = new ::std::string;
  }
  pass_->assign(value);
  // @@protoc_insertion_point(field_set:data.Account.pass)
}
inline void Account::set_pass(const char* value) {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_ = new ::std::string;
  }
  pass_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.Account.pass)
}
inline void Account::set_pass(const char* value, size_t size) {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_ = new ::std::string;
  }
  pass_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.Account.pass)
}
inline ::std::string* Account::mutable_pass() {
  set_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    pass_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.Account.pass)
  return pass_;
}
inline ::std::string* Account::release_pass() {
  clear_has_pass();
  if (pass_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = pass_;
    pass_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Account::set_allocated_pass(::std::string* pass) {
  if (pass_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete pass_;
  }
  if (pass) {
    set_has_pass();
    pass_ = pass;
  } else {
    clear_has_pass();
    pass_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.Account.pass)
}

// required string secure_host = 5;
inline bool Account::has_secure_host() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Account::set_has_secure_host() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Account::clear_has_secure_host() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Account::clear_secure_host() {
  if (secure_host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secure_host_->clear();
  }
  clear_has_secure_host();
}
inline const ::std::string& Account::secure_host() const {
  // @@protoc_insertion_point(field_get:data.Account.secure_host)
  return *secure_host_;
}
inline void Account::set_secure_host(const ::std::string& value) {
  set_has_secure_host();
  if (secure_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secure_host_ = new ::std::string;
  }
  secure_host_->assign(value);
  // @@protoc_insertion_point(field_set:data.Account.secure_host)
}
inline void Account::set_secure_host(const char* value) {
  set_has_secure_host();
  if (secure_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secure_host_ = new ::std::string;
  }
  secure_host_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.Account.secure_host)
}
inline void Account::set_secure_host(const char* value, size_t size) {
  set_has_secure_host();
  if (secure_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secure_host_ = new ::std::string;
  }
  secure_host_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.Account.secure_host)
}
inline ::std::string* Account::mutable_secure_host() {
  set_has_secure_host();
  if (secure_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    secure_host_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.Account.secure_host)
  return secure_host_;
}
inline ::std::string* Account::release_secure_host() {
  clear_has_secure_host();
  if (secure_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = secure_host_;
    secure_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Account::set_allocated_secure_host(::std::string* secure_host) {
  if (secure_host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete secure_host_;
  }
  if (secure_host) {
    set_has_secure_host();
    secure_host_ = secure_host;
  } else {
    clear_has_secure_host();
    secure_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.Account.secure_host)
}

// required uint32 secure_port = 6;
inline bool Account::has_secure_port() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Account::set_has_secure_port() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Account::clear_has_secure_port() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Account::clear_secure_port() {
  secure_port_ = 0u;
  clear_has_secure_port();
}
inline ::google::protobuf::uint32 Account::secure_port() const {
  // @@protoc_insertion_point(field_get:data.Account.secure_port)
  return secure_port_;
}
inline void Account::set_secure_port(::google::protobuf::uint32 value) {
  set_has_secure_port();
  secure_port_ = value;
  // @@protoc_insertion_point(field_set:data.Account.secure_port)
}

// required string general_host = 7;
inline bool Account::has_general_host() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Account::set_has_general_host() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Account::clear_has_general_host() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Account::clear_general_host() {
  if (general_host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    general_host_->clear();
  }
  clear_has_general_host();
}
inline const ::std::string& Account::general_host() const {
  // @@protoc_insertion_point(field_get:data.Account.general_host)
  return *general_host_;
}
inline void Account::set_general_host(const ::std::string& value) {
  set_has_general_host();
  if (general_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    general_host_ = new ::std::string;
  }
  general_host_->assign(value);
  // @@protoc_insertion_point(field_set:data.Account.general_host)
}
inline void Account::set_general_host(const char* value) {
  set_has_general_host();
  if (general_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    general_host_ = new ::std::string;
  }
  general_host_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.Account.general_host)
}
inline void Account::set_general_host(const char* value, size_t size) {
  set_has_general_host();
  if (general_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    general_host_ = new ::std::string;
  }
  general_host_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.Account.general_host)
}
inline ::std::string* Account::mutable_general_host() {
  set_has_general_host();
  if (general_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    general_host_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.Account.general_host)
  return general_host_;
}
inline ::std::string* Account::release_general_host() {
  clear_has_general_host();
  if (general_host_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = general_host_;
    general_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Account::set_allocated_general_host(::std::string* general_host) {
  if (general_host_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete general_host_;
  }
  if (general_host) {
    set_has_general_host();
    general_host_ = general_host;
  } else {
    clear_has_general_host();
    general_host_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.Account.general_host)
}

// required uint32 general_port = 8;
inline bool Account::has_general_port() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Account::set_has_general_port() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Account::clear_has_general_port() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Account::clear_general_port() {
  general_port_ = 0u;
  clear_has_general_port();
}
inline ::google::protobuf::uint32 Account::general_port() const {
  // @@protoc_insertion_point(field_get:data.Account.general_port)
  return general_port_;
}
inline void Account::set_general_port(::google::protobuf::uint32 value) {
  set_has_general_port();
  general_port_ = value;
  // @@protoc_insertion_point(field_set:data.Account.general_port)
}

// required uint32 max_connections = 9;
inline bool Account::has_max_connections() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Account::set_has_max_connections() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Account::clear_has_max_connections() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Account::clear_max_connections() {
  max_connections_ = 0u;
  clear_has_max_connections();
}
inline ::google::protobuf::uint32 Account::max_connections() const {
  // @@protoc_insertion_point(field_get:data.Account.max_connections)
  return max_connections_;
}
inline void Account::set_max_connections(::google::protobuf::uint32 value) {
  set_has_max_connections();
  max_connections_ = value;
  // @@protoc_insertion_point(field_set:data.Account.max_connections)
}

// required bool enable_secure_server = 10;
inline bool Account::has_enable_secure_server() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void Account::set_has_enable_secure_server() {
  _has_bits_[0] |= 0x00000200u;
}
inline void Account::clear_has_enable_secure_server() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void Account::clear_enable_secure_server() {
  enable_secure_server_ = false;
  clear_has_enable_secure_server();
}
inline bool Account::enable_secure_server() const {
  // @@protoc_insertion_point(field_get:data.Account.enable_secure_server)
  return enable_secure_server_;
}
inline void Account::set_enable_secure_server(bool value) {
  set_has_enable_secure_server();
  enable_secure_server_ = value;
  // @@protoc_insertion_point(field_set:data.Account.enable_secure_server)
}

// required bool enable_general_server = 11;
inline bool Account::has_enable_general_server() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void Account::set_has_enable_general_server() {
  _has_bits_[0] |= 0x00000400u;
}
inline void Account::clear_has_enable_general_server() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void Account::clear_enable_general_server() {
  enable_general_server_ = false;
  clear_has_enable_general_server();
}
inline bool Account::enable_general_server() const {
  // @@protoc_insertion_point(field_get:data.Account.enable_general_server)
  return enable_general_server_;
}
inline void Account::set_enable_general_server(bool value) {
  set_has_enable_general_server();
  enable_general_server_ = value;
  // @@protoc_insertion_point(field_set:data.Account.enable_general_server)
}

// required bool enable_pipelining = 12;
inline bool Account::has_enable_pipelining() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void Account::set_has_enable_pipelining() {
  _has_bits_[0] |= 0x00000800u;
}
inline void Account::clear_has_enable_pipelining() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void Account::clear_enable_pipelining() {
  enable_pipelining_ = false;
  clear_has_enable_pipelining();
}
inline bool Account::enable_pipelining() const {
  // @@protoc_insertion_point(field_get:data.Account.enable_pipelining)
  return enable_pipelining_;
}
inline void Account::set_enable_pipelining(bool value) {
  set_has_enable_pipelining();
  enable_pipelining_ = value;
  // @@protoc_insertion_point(field_set:data.Account.enable_pipelining)
}

// required bool enable_compression = 13;
inline bool Account::has_enable_compression() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void Account::set_has_enable_compression() {
  _has_bits_[0] |= 0x00001000u;
}
inline void Account::clear_has_enable_compression() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void Account::clear_enable_compression() {
  enable_compression_ = false;
  clear_has_enable_compression();
}
inline bool Account::enable_compression() const {
  // @@protoc_insertion_point(field_get:data.Account.enable_compression)
  return enable_compression_;
}
inline void Account::set_enable_compression(bool value) {
  set_has_enable_compression();
  enable_compression_ = value;
  // @@protoc_insertion_point(field_set:data.Account.enable_compression)
}

// -------------------------------------------------------------------

// File

// required string filename = 1;
inline bool File::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void File::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void File::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void File::clear_filename() {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& File::filename() const {
  // @@protoc_insertion_point(field_get:data.File.filename)
  return *filename_;
}
inline void File::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set:data.File.filename)
}
inline void File::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.File.filename)
}
inline void File::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.File.filename)
}
inline ::std::string* File::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filename_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.File.filename)
  return filename_;
}
inline ::std::string* File::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void File::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.File.filename)
}

// required string filepath = 2;
inline bool File::has_filepath() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void File::set_has_filepath() {
  _has_bits_[0] |= 0x00000002u;
}
inline void File::clear_has_filepath() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void File::clear_filepath() {
  if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_->clear();
  }
  clear_has_filepath();
}
inline const ::std::string& File::filepath() const {
  // @@protoc_insertion_point(field_get:data.File.filepath)
  return *filepath_;
}
inline void File::set_filepath(const ::std::string& value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
  // @@protoc_insertion_point(field_set:data.File.filepath)
}
inline void File::set_filepath(const char* value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.File.filepath)
}
inline void File::set_filepath(const char* value, size_t size) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.File.filepath)
}
inline ::std::string* File::mutable_filepath() {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    filepath_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.File.filepath)
  return filepath_;
}
inline ::std::string* File::release_filepath() {
  clear_has_filepath();
  if (filepath_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = filepath_;
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void File::set_allocated_filepath(::std::string* filepath) {
  if (filepath_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete filepath_;
  }
  if (filepath) {
    set_has_filepath();
    filepath_ = filepath;
  } else {
    clear_has_filepath();
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.File.filepath)
}

// required string dataname = 3;
inline bool File::has_dataname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void File::set_has_dataname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void File::clear_has_dataname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void File::clear_dataname() {
  if (dataname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataname_->clear();
  }
  clear_has_dataname();
}
inline const ::std::string& File::dataname() const {
  // @@protoc_insertion_point(field_get:data.File.dataname)
  return *dataname_;
}
inline void File::set_dataname(const ::std::string& value) {
  set_has_dataname();
  if (dataname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataname_ = new ::std::string;
  }
  dataname_->assign(value);
  // @@protoc_insertion_point(field_set:data.File.dataname)
}
inline void File::set_dataname(const char* value) {
  set_has_dataname();
  if (dataname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataname_ = new ::std::string;
  }
  dataname_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.File.dataname)
}
inline void File::set_dataname(const char* value, size_t size) {
  set_has_dataname();
  if (dataname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataname_ = new ::std::string;
  }
  dataname_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.File.dataname)
}
inline ::std::string* File::mutable_dataname() {
  set_has_dataname();
  if (dataname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    dataname_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.File.dataname)
  return dataname_;
}
inline ::std::string* File::release_dataname() {
  clear_has_dataname();
  if (dataname_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = dataname_;
    dataname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void File::set_allocated_dataname(::std::string* dataname) {
  if (dataname_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete dataname_;
  }
  if (dataname) {
    set_has_dataname();
    dataname_ = dataname;
  } else {
    clear_has_dataname();
    dataname_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.File.dataname)
}

// required bool is_binary = 4;
inline bool File::has_is_binary() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void File::set_has_is_binary() {
  _has_bits_[0] |= 0x00000008u;
}
inline void File::clear_has_is_binary() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void File::clear_is_binary() {
  is_binary_ = false;
  clear_has_is_binary();
}
inline bool File::is_binary() const {
  // @@protoc_insertion_point(field_get:data.File.is_binary)
  return is_binary_;
}
inline void File::set_is_binary(bool value) {
  set_has_is_binary();
  is_binary_ = value;
  // @@protoc_insertion_point(field_set:data.File.is_binary)
}

// -------------------------------------------------------------------

// Stash

// required uint32 sequence = 1;
inline bool Stash::has_sequence() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Stash::set_has_sequence() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Stash::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Stash::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 Stash::sequence() const {
  // @@protoc_insertion_point(field_get:data.Stash.sequence)
  return sequence_;
}
inline void Stash::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:data.Stash.sequence)
}

// required bytes data = 2;
inline bool Stash::has_data() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Stash::set_has_data() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Stash::clear_has_data() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Stash::clear_data() {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_->clear();
  }
  clear_has_data();
}
inline const ::std::string& Stash::data() const {
  // @@protoc_insertion_point(field_get:data.Stash.data)
  return *data_;
}
inline void Stash::set_data(const ::std::string& value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set:data.Stash.data)
}
inline void Stash::set_data(const char* value) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.Stash.data)
}
inline void Stash::set_data(const void* value, size_t size) {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  data_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.Stash.data)
}
inline ::std::string* Stash::mutable_data() {
  set_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    data_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.Stash.data)
  return data_;
}
inline ::std::string* Stash::release_data() {
  clear_has_data();
  if (data_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = data_;
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Stash::set_allocated_data(::std::string* data) {
  if (data_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete data_;
  }
  if (data) {
    set_has_data();
    data_ = data;
  } else {
    clear_has_data();
    data_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.Stash.data)
}

// -------------------------------------------------------------------

// Download

// repeated string article = 1;
inline int Download::article_size() const {
  return article_.size();
}
inline void Download::clear_article() {
  article_.Clear();
}
inline const ::std::string& Download::article(int index) const {
  // @@protoc_insertion_point(field_get:data.Download.article)
  return article_.Get(index);
}
inline ::std::string* Download::mutable_article(int index) {
  // @@protoc_insertion_point(field_mutable:data.Download.article)
  return article_.Mutable(index);
}
inline void Download::set_article(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:data.Download.article)
  article_.Mutable(index)->assign(value);
}
inline void Download::set_article(int index, const char* value) {
  article_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:data.Download.article)
}
inline void Download::set_article(int index, const char* value, size_t size) {
  article_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.Download.article)
}
inline ::std::string* Download::add_article() {
  return article_.Add();
}
inline void Download::add_article(const ::std::string& value) {
  article_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:data.Download.article)
}
inline void Download::add_article(const char* value) {
  article_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:data.Download.article)
}
inline void Download::add_article(const char* value, size_t size) {
  article_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:data.Download.article)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Download::article() const {
  // @@protoc_insertion_point(field_list:data.Download.article)
  return article_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Download::mutable_article() {
  // @@protoc_insertion_point(field_mutable_list:data.Download.article)
  return &article_;
}

// repeated string group = 2;
inline int Download::group_size() const {
  return group_.size();
}
inline void Download::clear_group() {
  group_.Clear();
}
inline const ::std::string& Download::group(int index) const {
  // @@protoc_insertion_point(field_get:data.Download.group)
  return group_.Get(index);
}
inline ::std::string* Download::mutable_group(int index) {
  // @@protoc_insertion_point(field_mutable:data.Download.group)
  return group_.Mutable(index);
}
inline void Download::set_group(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:data.Download.group)
  group_.Mutable(index)->assign(value);
}
inline void Download::set_group(int index, const char* value) {
  group_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:data.Download.group)
}
inline void Download::set_group(int index, const char* value, size_t size) {
  group_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.Download.group)
}
inline ::std::string* Download::add_group() {
  return group_.Add();
}
inline void Download::add_group(const ::std::string& value) {
  group_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:data.Download.group)
}
inline void Download::add_group(const char* value) {
  group_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:data.Download.group)
}
inline void Download::add_group(const char* value, size_t size) {
  group_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:data.Download.group)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
Download::group() const {
  // @@protoc_insertion_point(field_list:data.Download.group)
  return group_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
Download::mutable_group() {
  // @@protoc_insertion_point(field_mutable_list:data.Download.group)
  return &group_;
}

// required uint32 num_decode_jobs = 3;
inline bool Download::has_num_decode_jobs() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Download::set_has_num_decode_jobs() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Download::clear_has_num_decode_jobs() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Download::clear_num_decode_jobs() {
  num_decode_jobs_ = 0u;
  clear_has_num_decode_jobs();
}
inline ::google::protobuf::uint32 Download::num_decode_jobs() const {
  // @@protoc_insertion_point(field_get:data.Download.num_decode_jobs)
  return num_decode_jobs_;
}
inline void Download::set_num_decode_jobs(::google::protobuf::uint32 value) {
  set_has_num_decode_jobs();
  num_decode_jobs_ = value;
  // @@protoc_insertion_point(field_set:data.Download.num_decode_jobs)
}

// required uint32 num_actions_total = 4;
inline bool Download::has_num_actions_total() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Download::set_has_num_actions_total() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Download::clear_has_num_actions_total() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Download::clear_num_actions_total() {
  num_actions_total_ = 0u;
  clear_has_num_actions_total();
}
inline ::google::protobuf::uint32 Download::num_actions_total() const {
  // @@protoc_insertion_point(field_get:data.Download.num_actions_total)
  return num_actions_total_;
}
inline void Download::set_num_actions_total(::google::protobuf::uint32 value) {
  set_has_num_actions_total();
  num_actions_total_ = value;
  // @@protoc_insertion_point(field_set:data.Download.num_actions_total)
}

// required uint32 num_actions_ready = 5;
inline bool Download::has_num_actions_ready() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Download::set_has_num_actions_ready() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Download::clear_has_num_actions_ready() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Download::clear_num_actions_ready() {
  num_actions_ready_ = 0u;
  clear_has_num_actions_ready();
}
inline ::google::protobuf::uint32 Download::num_actions_ready() const {
  // @@protoc_insertion_point(field_get:data.Download.num_actions_ready)
  return num_actions_ready_;
}
inline void Download::set_num_actions_ready(::google::protobuf::uint32 value) {
  set_has_num_actions_ready();
  num_actions_ready_ = value;
  // @@protoc_insertion_point(field_set:data.Download.num_actions_ready)
}

// repeated .data.File file = 6;
inline int Download::file_size() const {
  return file_.size();
}
inline void Download::clear_file() {
  file_.Clear();
}
inline const ::data::File& Download::file(int index) const {
  // @@protoc_insertion_point(field_get:data.Download.file)
  return file_.Get(index);
}
inline ::data::File* Download::mutable_file(int index) {
  // @@protoc_insertion_point(field_mutable:data.Download.file)
  return file_.Mutable(index);
}
inline ::data::File* Download::add_file() {
  // @@protoc_insertion_point(field_add:data.Download.file)
  return file_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::data::File >&
Download::file() const {
  // @@protoc_insertion_point(field_list:data.Download.file)
  return file_;
}
inline ::google::protobuf::RepeatedPtrField< ::data::File >*
Download::mutable_file() {
  // @@protoc_insertion_point(field_mutable_list:data.Download.file)
  return &file_;
}

// repeated .data.Stash stash = 7;
inline int Download::stash_size() const {
  return stash_.size();
}
inline void Download::clear_stash() {
  stash_.Clear();
}
inline const ::data::Stash& Download::stash(int index) const {
  // @@protoc_insertion_point(field_get:data.Download.stash)
  return stash_.Get(index);
}
inline ::data::Stash* Download::mutable_stash(int index) {
  // @@protoc_insertion_point(field_mutable:data.Download.stash)
  return stash_.Mutable(index);
}
inline ::data::Stash* Download::add_stash() {
  // @@protoc_insertion_point(field_add:data.Download.stash)
  return stash_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::data::Stash >&
Download::stash() const {
  // @@protoc_insertion_point(field_list:data.Download.stash)
  return stash_;
}
inline ::google::protobuf::RepeatedPtrField< ::data::Stash >*
Download::mutable_stash() {
  // @@protoc_insertion_point(field_mutable_list:data.Download.stash)
  return &stash_;
}

// -------------------------------------------------------------------

// TaskState

// required uint32 account_id = 1;
inline bool TaskState::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskState::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskState::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskState::clear_account_id() {
  account_id_ = 0u;
  clear_has_account_id();
}
inline ::google::protobuf::uint32 TaskState::account_id() const {
  // @@protoc_insertion_point(field_get:data.TaskState.account_id)
  return account_id_;
}
inline void TaskState::set_account_id(::google::protobuf::uint32 value) {
  set_has_account_id();
  account_id_ = value;
  // @@protoc_insertion_point(field_set:data.TaskState.account_id)
}

// required uint32 batch_id = 2;
inline bool TaskState::has_batch_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskState::set_has_batch_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskState::clear_has_batch_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskState::clear_batch_id() {
  batch_id_ = 0u;
  clear_has_batch_id();
}
inline ::google::protobuf::uint32 TaskState::batch_id() const {
  // @@protoc_insertion_point(field_get:data.TaskState.batch_id)
  return batch_id_;
}
inline void TaskState::set_batch_id(::google::protobuf::uint32 value) {
  set_has_batch_id();
  batch_id_ = value;
  // @@protoc_insertion_point(field_set:data.TaskState.batch_id)
}

// required uint32 task_id = 3;
inline bool TaskState::has_task_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskState::set_has_task_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskState::clear_has_task_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskState::clear_task_id() {
  task_id_ = 0u;
  clear_has_task_id();
}
inline ::google::protobuf::uint32 TaskState::task_id() const {
  // @@protoc_insertion_point(field_get:data.TaskState.task_id)
  return task_id_;
}
inline void TaskState::set_task_id(::google::protobuf::uint32 value) {
  set_has_task_id();
  task_id_ = value;
  // @@protoc_insertion_point(field_set:data.TaskState.task_id)
}

// required string desc = 4;
inline bool TaskState::has_desc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TaskState::set_has_desc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TaskState::clear_has_desc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TaskState::clear_desc() {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& TaskState::desc() const {
  // @@protoc_insertion_point(field_get:data.TaskState.desc)
  return *desc_;
}
inline void TaskState::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:data.TaskState.desc)
}
inline void TaskState::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.TaskState.desc)
}
inline void TaskState::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.TaskState.desc)
}
inline ::std::string* TaskState::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.TaskState.desc)
  return desc_;
}
inline ::std::string* TaskState::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TaskState::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.TaskState.desc)
}

// required string path = 5;
inline bool TaskState::has_path() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TaskState::set_has_path() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TaskState::clear_has_path() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TaskState::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& TaskState::path() const {
  // @@protoc_insertion_point(field_get:data.TaskState.path)
  return *path_;
}
inline void TaskState::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:data.TaskState.path)
}
inline void TaskState::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.TaskState.path)
}
inline void TaskState::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.TaskState.path)
}
inline ::std::string* TaskState::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.TaskState.path)
  return path_;
}
inline ::std::string* TaskState::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void TaskState::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.TaskState.path)
}

// required uint64 size = 6;
inline bool TaskState::has_size() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TaskState::set_has_size() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TaskState::clear_has_size() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TaskState::clear_size() {
  size_ = GOOGLE_ULONGLONG(0);
  clear_has_size();
}
inline ::google::protobuf::uint64 TaskState::size() const {
  // @@protoc_insertion_point(field_get:data.TaskState.size)
  return size_;
}
inline void TaskState::set_size(::google::protobuf::uint64 value) {
  set_has_size();
  size_ = value;
  // @@protoc_insertion_point(field_set:data.TaskState.size)
}

// optional .data.Download download = 7;
inline bool TaskState::has_download() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TaskState::set_has_download() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TaskState::clear_has_download() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TaskState::clear_download() {
  if (download_ != NULL) download_->::data::Download::Clear();
  clear_has_download();
}
inline const ::data::Download& TaskState::download() const {
  // @@protoc_insertion_point(field_get:data.TaskState.download)
  return download_ != NULL ? *download_ : *default_instance_->download_;
}
inline ::data::Download* TaskState::mutable_download() {
  set_has_download();
  if (download_ == NULL) download_ = new ::data::Download;
  // @@protoc_insertion_point(field_mutable:data.TaskState.download)
  return download_;
}
inline ::data::Download* TaskState::release_download() {
  clear_has_download();
  ::data::Download* temp = download_;
  download_ = NULL;
  return temp;
}
inline void TaskState::set_allocated_download(::data::Download* download) {
  delete download_;
  download_ = download;
  if (download) {
    set_has_download();
  } else {
    clear_has_download();
  }
  // @@protoc_insertion_point(field_set_allocated:data.TaskState.download)
}

// -------------------------------------------------------------------

// Batch

// required uint32 account_id = 1;
inline bool Batch::has_account_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Batch::set_has_account_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Batch::clear_has_account_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Batch::clear_account_id() {
  account_id_ = 0u;
  clear_has_account_id();
}
inline ::google::protobuf::uint32 Batch::account_id() const {
  // @@protoc_insertion_point(field_get:data.Batch.account_id)
  return account_id_;
}
inline void Batch::set_account_id(::google::protobuf::uint32 value) {
  set_has_account_id();
  account_id_ = value;
  // @@protoc_insertion_point(field_set:data.Batch.account_id)
}

// required uint32 batch_id = 2;
inline bool Batch::has_batch_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Batch::set_has_batch_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Batch::clear_has_batch_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Batch::clear_batch_id() {
  batch_id_ = 0u;
  clear_has_batch_id();
}
inline ::google::protobuf::uint32 Batch::batch_id() const {
  // @@protoc_insertion_point(field_get:data.Batch.batch_id)
  return batch_id_;
}
inline void Batch::set_batch_id(::google::protobuf::uint32 value) {
  set_has_batch_id();
  batch_id_ = value;
  // @@protoc_insertion_point(field_set:data.Batch.batch_id)
}

// required string path = 3;
inline bool Batch::has_path() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Batch::set_has_path() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Batch::clear_has_path() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Batch::clear_path() {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& Batch::path() const {
  // @@protoc_insertion_point(field_get:data.Batch.path)
  return *path_;
}
inline void Batch::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set:data.Batch.path)
}
inline void Batch::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.Batch.path)
}
inline void Batch::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.Batch.path)
}
inline ::std::string* Batch::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    path_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.Batch.path)
  return path_;
}
inline ::std::string* Batch::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Batch::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.Batch.path)
}

// required string desc = 4;
inline bool Batch::has_desc() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Batch::set_has_desc() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Batch::clear_has_desc() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Batch::clear_desc() {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_->clear();
  }
  clear_has_desc();
}
inline const ::std::string& Batch::desc() const {
  // @@protoc_insertion_point(field_get:data.Batch.desc)
  return *desc_;
}
inline void Batch::set_desc(const ::std::string& value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set:data.Batch.desc)
}
inline void Batch::set_desc(const char* value) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(value);
  // @@protoc_insertion_point(field_set_char:data.Batch.desc)
}
inline void Batch::set_desc(const char* value, size_t size) {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  desc_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:data.Batch.desc)
}
inline ::std::string* Batch::mutable_desc() {
  set_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    desc_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:data.Batch.desc)
  return desc_;
}
inline ::std::string* Batch::release_desc() {
  clear_has_desc();
  if (desc_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = desc_;
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void Batch::set_allocated_desc(::std::string* desc) {
  if (desc_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete desc_;
  }
  if (desc) {
    set_has_desc();
    desc_ = desc;
  } else {
    clear_has_desc();
    desc_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:data.Batch.desc)
}

// required uint64 byte_size = 5;
inline bool Batch::has_byte_size() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Batch::set_has_byte_size() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Batch::clear_has_byte_size() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Batch::clear_byte_size() {
  byte_size_ = GOOGLE_ULONGLONG(0);
  clear_has_byte_size();
}
inline ::google::protobuf::uint64 Batch::byte_size() const {
  // @@protoc_insertion_point(field_get:data.Batch.byte_size)
  return byte_size_;
}
inline void Batch::set_byte_size(::google::protobuf::uint64 value) {
  set_has_byte_size();
  byte_size_ = value;
  // @@protoc_insertion_point(field_set:data.Batch.byte_size)
}

// required uint32 num_tasks = 6;
inline bool Batch::has_num_tasks() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Batch::set_has_num_tasks() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Batch::clear_has_num_tasks() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Batch::clear_num_tasks() {
  num_tasks_ = 0u;
  clear_has_num_tasks();
}
inline ::google::protobuf::uint32 Batch::num_tasks() const {
  // @@protoc_insertion_point(field_get:data.Batch.num_tasks)
  return num_tasks_;
}
inline void Batch::set_num_tasks(::google::protobuf::uint32 value) {
  set_has_num_tasks();
  num_tasks_ = value;
  // @@protoc_insertion_point(field_set:data.Batch.num_tasks)
}

// required uint32 num_slices = 7;
inline bool Batch::has_num_slices() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Batch::set_has_num_slices() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Batch::clear_has_num_slices() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Batch::clear_num_slices() {
  num_slices_ = 0u;
  clear_has_num_slices();
}
inline ::google::protobuf::uint32 Batch::num_slices() const {
  // @@protoc_insertion_point(field_get:data.Batch.num_slices)
  return num_slices_;
}
inline void Batch::set_num_slices(::google::protobuf::uint32 value) {
  set_has_num_slices();
  num_slices_ = value;
  // @@protoc_insertion_point(field_set:data.Batch.num_slices)
}

// -------------------------------------------------------------------

// TaskList

// required uint32 current_id = 1;
inline bool TaskList::has_current_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TaskList::set_has_current_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TaskList::clear_has_current_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TaskList::clear_current_id() {
  current_id_ = 0u;
  clear_has_current_id();
}
inline ::google::protobuf::uint32 TaskList::current_id() const {
  // @@protoc_insertion_point(field_get:data.TaskList.current_id)
  return current_id_;
}
inline void TaskList::set_current_id(::google::protobuf::uint32 value) {
  set_has_current_id();
  current_id_ = value;
  // @@protoc_insertion_point(field_set:data.TaskList.current_id)
}

// required uint64 bytes_queued = 2;
inline bool TaskList::has_bytes_queued() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TaskList::set_has_bytes_queued() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TaskList::clear_has_bytes_queued() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TaskList::clear_bytes_queued() {
  bytes_queued_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_queued();
}
inline ::google::protobuf::uint64 TaskList::bytes_queued() const {
  // @@protoc_insertion_point(field_get:data.TaskList.bytes_queued)
  return bytes_queued_;
}
inline void TaskList::set_bytes_queued(::google::protobuf::uint64 value) {
  set_has_bytes_queued();
  bytes_queued_ = value;
  // @@protoc_insertion_point(field_set:data.TaskList.bytes_queued)
}

// required uint64 bytes_ready = 3;
inline bool TaskList::has_bytes_ready() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TaskList::set_has_bytes_ready() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TaskList::clear_has_bytes_ready() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TaskList::clear_bytes_ready() {
  bytes_ready_ = GOOGLE_ULONGLONG(0);
  clear_has_bytes_ready();
}
inline ::google::protobuf::uint64 TaskList::bytes_ready() const {
  // @@protoc_insertion_point(field_get:data.TaskList.bytes_ready)
  return bytes_ready_;
}
inline void TaskList::set_bytes_ready(::google::protobuf::uint64 value) {
  set_has_bytes_ready();
  bytes_ready_ = value;
  // @@protoc_insertion_point(field_set:data.TaskList.bytes_ready)
}

// repeated .data.Account account = 4;
inline int TaskList::account_size() const {
  return account_.size();
}
inline void TaskList::clear_account() {
  account_.Clear();
}
inline const ::data::Account& TaskList::account(int index) const {
  // @@protoc_insertion_point(field_get:data.TaskList.account)
  return account_.Get(index);
}
inline ::data::Account* TaskList::mutable_account(int index) {
  // @@protoc_insertion_point(field_mutable:data.TaskList.account)
  return account_.Mutable(index);
}
inline ::data::Account* TaskList::add_account() {
  // @@protoc_insertion_point(field_add:data.TaskList.account)
  return account_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::data::Account >&
TaskList::account() const {
  // @@protoc_insertion_point(field_list:data.TaskList.account)
  return account_;
}
inline ::google::protobuf::RepeatedPtrField< ::data::Account >*
TaskList::mutable_account() {
  // @@protoc_insertion_point(field_mutable_list:data.TaskList.account)
  return &account_;
}

// repeated .data.Batch batch = 5;
inline int TaskList::batch_size() const {
  return batch_.size();
}
inline void TaskList::clear_batch() {
  batch_.Clear();
}
inline const ::data::Batch& TaskList::batch(int index) const {
  // @@protoc_insertion_point(field_get:data.TaskList.batch)
  return batch_.Get(index);
}
inline ::data::Batch* TaskList::mutable_batch(int index) {
  // @@protoc_insertion_point(field_mutable:data.TaskList.batch)
  return batch_.Mutable(index);
}
inline ::data::Batch* TaskList::add_batch() {
  // @@protoc_insertion_point(field_add:data.TaskList.batch)
  return batch_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::data::Batch >&
TaskList::batch() const {
  // @@protoc_insertion_point(field_list:data.TaskList.batch)
  return batch_;
}
inline ::google::protobuf::RepeatedPtrField< ::data::Batch >*
TaskList::mutable_batch() {
  // @@protoc_insertion_point(field_mutable_list:data.TaskList.batch)
  return &batch_;
}

// repeated .data.TaskState tasks = 6;
inline int TaskList::tasks_size() const {
  return tasks_.size();
}
inline void TaskList::clear_tasks() {
  tasks_.Clear();
}
inline const ::data::TaskState& TaskList::tasks(int index) const {
  // @@protoc_insertion_point(field_get:data.TaskList.tasks)
  return tasks_.Get(index);
}
inline ::data::TaskState* TaskList::mutable_tasks(int index) {
  // @@protoc_insertion_point(field_mutable:data.TaskList.tasks)
  return tasks_.Mutable(index);
}
inline ::data::TaskState* TaskList::add_tasks() {
  // @@protoc_insertion_point(field_add:data.TaskList.tasks)
  return tasks_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::data::TaskState >&
TaskList::tasks() const {
  // @@protoc_insertion_point(field_list:data.TaskList.tasks)
  return tasks_;
}
inline ::google::protobuf::RepeatedPtrField< ::data::TaskState >*
TaskList::mutable_tasks() {
  // @@protoc_insertion_point(field_mutable_list:data.TaskList.tasks)
  return &tasks_;
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace data

#ifndef SWIG
namespace google {
namespace protobuf {


}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_engine_2eproto__INCLUDED

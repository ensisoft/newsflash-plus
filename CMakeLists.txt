cmake_minimum_required(VERSION 3.0)

project(NewsflashPlus)

message(STATUS "
      ~~ Newsflash Plus ~~
     World's best newsreader!
\\\\o Brought to you by Ensisoft o//
     http://www.ensisoft.com
Copyright (c) 2010-2017 Sami Väisänen
             Ensisoft

https://github.com/ensisoft/newsflash-plus
")

if (NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Debug)
    message("
This is the Debug build (by default)
For Release build use the following:

cmake -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release
")
endif(NOT CMAKE_BUILD_TYPE)

# set this to ON when CVomit fails to work automatically.
#set(Boost_DEBUG ON)

set(Boost_USE_MULTITHREADED  ON)
set(Boost_USE_STATIC_LIBS    ON)
set(Boost_USE_STATIC_RUNTIME OFF)
# for whatever reason CVomit thinks we're using vc120... but our build chain is MSVS 2013 (vc110)
if (WIN32)
  set(Boost_COMPILER "-vc110")
endif()
set(BOOST_ROOT       "${CMAKE_CURRENT_LIST_DIR}/third_party/boost_1_51_0/sdk")
set(BOOST_INCLUDEDIR "${CMAKE_CURRENT_LIST_DIR}/third_party/boost_1_51_0/sdk/include/")
set(BOOST_LIBRARYDIR "${CMAKE_CURRENT_LIST_DIR}/third_party/boost_1_51_0/sdk/lib")


find_package(Boost REQUIRED COMPONENTS filesystem thread regex system)
if(NOT Boost_FOUND)
    message(FATAL_ERROR
"Shit. Couldn't find Boost third_party/boost_1_51_0"
    )
endif()

# If you set QT_QMAKE_EXECUTABLE to the full path to a qmake *that* qmake is used
# above all else to find the right Qt. Regardless of QTDIR or PATH.
# Setting QT_QMAKE_EXECUTABLE is *the* official way to tell CMake where the Qt
# that you want is. All else is a "find-and-guess" game if you have multiple Qt's available.
# https://public.kitware.com/pipermail/cmake/2009-March/027708.html
set(QT_QMAKE_EXECUTABLE "${CMAKE_CURRENT_LIST_DIR}/third_party/qt-4.8.6/bin/qmake")
find_package(Qt4 REQUIRED)

message(STATUS "${Boost_INCLUDE_DIRS}")
message(STATUS "${Boost_LIBRARY_DIRS}")
message(STATUS "${Boost_LIBRARIES}")

set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTORCC ON)

# generic include directories (same for each platform)
include_directories(BEFORE "${CMAKE_CURRENT_LIST_DIR}/third_party/qjson/include")
include_directories(BEFORE "${CMAKE_CURRENT_LIST_DIR}/third_party")
include_directories(BEFORE "${CMAKE_CURRENT_LIST_DIR}/third_party/openssl/sdk/include")
include_directories(BEFORE "${CMAKE_CURRENT_LIST_DIR}/third_party/protobuf/src")
include_directories(BEFORE "${CMAKE_CURRENT_LIST_DIR}/third_party/zlib")
include_directories(BEFORE "${Boost_INCLUDE_DIRS}")
# UI generated files do a global include for custom widgets such as the pieview.
# so we need to add the gui folder to the include list.
include_directories(BEFORE "${CMAKE_CURRENT_LIST_DIR}/gui")
# this tells cmake to include our *current* directory which is our build directory
# in which the Qt tools (moc and uic) will spit out their generated files.
# so for example when you have "include ui_foobar.h" in your code the
# ui_foobar.h is generated by UIC and will be placed in the current dir.
set(CMAKE_INCLUDE_CURRENT_DIR ON)

# platform specific include dirs
if (WIN32)

elseif(UNIX)

endif()

# generic link directories (same for each platform)
link_directories("${CMAKE_CURRENT_LIST_DIR}/third_party/openssl/sdk/lib")
link_directories("${CMAKE_CURRENT_LIST_DIR}/third_party/boost_1_51_0/sdk/lib")

# platform specific link dirs
if (WIN32)
    # different iterator levels thus must use correct lib (either debug or release)
    if (CMAKE_BUILD_TYPE MATCHES "Release")
        link_directories("${CMAKE_CURRENT_LIST_DIR}/third_party/protobuf/vsprojects/x64/Release")
    elseif(CMAKE_BUILD_TYPE MATCHES "Debug")
        link_directories("${CMAKE_CURRENT_LIST_DIR}/third_party/protobuf/vsprojects/x64/Debug")
    endif()
    link_directories("${CMAKE_CURRENT_LIST_DIR}/third_party/qjson/lib/Release")
    link_directories("${CMAKE_CURRENT_LIST_DIR}/third_party/zlib/Release")
elseif(UNIX)
    link_directories("${CMAKE_CURRENT_LIST_DIR}/third_party/protobuf/lib")
    link_directories("${CMAKE_CURRENT_LIST_DIR}/third_party/qjson/lib")
    link_directories("${CMAKE_CURRENT_LIST_DIR}/third_party/zlib/")
endif()

if (WIN32)
    set(LIB_OPENSSL  "ssleay32")
    set(LIB_CRYPTO   "libeay32")
    set(LIB_Z        "zlib") # note that in a very gay fashion the lib is zlib.lib and the library is zlib1.dll
    set(LIB_PROTOBUF "libprotobuf")
elseif(UNIX)
    set(LIB_OPENSSL  "ssl")
    set(LIB_CRYPTO   "crypto")
    set(LIB_Z        "z")
    set(LIB_PROTOBUF "protobuf")
endif()

# compiler specific compiler & linker flags
if (CMAKE_COMPILER_IS_GNUCC)
    # we need -rdynamic for backtrace and backtrace_symbols
    # in order to dump a stacktrace from the ASSERT macro.
    set(CMAKE_EXE_LINKER_FLAGS    "${CMAKE_EXE_LINKER_FLAGS}    -rdynamic -pthread")
    set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -rdynamic -pthread")
    set(CMAKE_CXX_STANDARD 14)
elseif(MSVC)
    # /Zc:wchar_t  treats wchar_t as a native type
    # /Zc:wchar_t- treats wchar_t as a typedef for unsigned short.
    # Qt requires wchar_t- otherwise the types don't match.
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /Zc:wchar_t-")

    if (CMAKE_BUILD_TYPE MATCHES "Release")
        #  /Zi turns on the .pdb generation. We want this for the release build
        # so that we can do post-mortem debugging with the minidump (from the crash)
        # and the pdb file.
        # /FS is needed for parallel build. It forces data to be written
        # through a serialized surrogate process.
        # NOTE that the /Zi names the .pdb file as vcx0.pdb where the x is
        # the version number. So for example vc120.pdb
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /Zi")
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /FS")

        # http://www.wintellect.com/devcenter/jrobbins/correctly-creating-native-c-release-build-pdbs
        # need to tell the linker also about the debug data.
        set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /DEBUG")
        set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /OPT:REF")
        set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /OPT:ICF")
        set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} /DEBUG")
        set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} /OPT:REF")
        set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} /OPT:ICF")
    endif()

    # if this is not defined linking problems will happen on msvc
    add_definitions(-DBOOST_ALL_NO_LIB)
endif()

# build the smtpclient library
# it's in third_party but doesn't have a build file so we build it here.
# note that it's LGPL'ed so it needs to be a shared library.
file(GLOB SMTPCLIENT_SOURCE third_party/smtpclient/*.cpp)
add_library(smtpclient SHARED ${SMTPCLIENT_SOURCE})
target_link_libraries(smtpclient
    Qt4::QtCore
    Qt4::QtNetwork)
add_executable(smtpclient_test third_party/smtpclient/example/main.cpp)
target_link_libraries(smtpclient_test smtpclient Qt4::QtCore Qt4::QtGui)



# build the engine lib
file(GLOB ENGINE_SOURCE engine/*.cpp engine/*.cc)
add_library(engine STATIC ${ENGINE_SOURCE})
target_link_libraries(engine INTERFACE
    ${Boost_LIBRARIES}
    ${LIB_PROTOBUF}
    ${LIB_Z}
    ${LIB_OPENSSL}
    ${LIB_CRYPTO}
    smtpclient)

file(GLOB APP_SOURCE  app/*.h app/*.cpp)
file(GLOB GUI_SOURCE  gui/*.h gui/*.cpp gui/*.ui)

add_library(appcore STATIC
    ${APP_SOURCE}
    tools/keygen/keygen.cpp
    stringlib/string.cpp)

target_link_libraries(appcore PUBLIC
    engine
    qjson
    Qt4::QtCore
    Qt4::QtGui
    Qt4::QtXml
    Qt4::QtNetwork)

# build the main application
add_executable(newsflash
    ${GUI_SOURCE}
    gui/resource.qrc
    gui/qtsingleapplication/qtsingleapplication.h
    gui/qtsingleapplication/qtsingleapplication.cpp
    gui/qtsingleapplication/qtlocalpeer.h
    gui/qtsingleapplication/qtlocalpeer.cpp)

if (MSVC)
    # https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx
    # https://msdn.microsoft.com/en-us/library/windows/desktop/ms724832(v=vs.85).aspx
    #
    # this option is needed starting with msvc2012(?) to allow the binary run on WinXP.
    # NOTE: that it seems to be enough to have this on the executable, so theres
    # no need to dick around with Qt, json, zlib settings.
    #
    # WINDOWS, creates a win32 application that uses WinMain, no console.
    # CONSOLE, creates a console application that uses main(), system created console.
    # 5.2 = Win XP 64bit version
    if (CMAKE_BUILD_TYPE MATCHES "Release")
        set_target_properties(newsflash PROPERTIES LINK_FLAGS "/SUBSYSTEM:WINDOWS,5.2")
    elseif(CMAKE_BUILD_TYPE MATCHES "Debug")
        set_target_properties(newsflash PROPERTIES LINK_FLAGS "/SUBSYSTEM:CONSOLE,5.2")
    endif()
endif()
target_link_libraries(newsflash appcore)

# build the keygen
add_executable(keygen
    tools/keygen/main.cpp
    tools/keygen/keygen.cpp
    app/webengine.h
    app/webengine.cpp
    app/webquery.h
    app/webquery.cpp
    app/debug.h
    app/debug.cpp
    engine/assert.cpp)
target_link_libraries(keygen
    Qt4::QtCore
    Qt4::QtNetwork)

# build the join tool for joining .001, .002 ... files
add_executable(join tools/joiner/main.cpp)
target_link_libraries(join Qt4::QtCore)

# this is a dummy test server used by some of the test cases.
# it must be built and running before tests can be run.
add_executable(test_server engine/unit_test/server.cpp)
target_link_libraries(test_server engine)

# build unit test.
enable_testing()

add_executable(unit_test_utf8        engine/unit_test/unit_test_utf8.cpp)
add_executable(unit_test_uuencode    engine/unit_test/unit_test_uuencode.cpp)
add_executable(unit_test_yenc        engine/unit_test/unit_test_yenc.cpp)
add_executable(unit_test_session     engine/unit_test/unit_test_session.cpp)
add_executable(unit_test_buffer      engine/unit_test/unit_test_buffer.cpp)
add_executable(unit_test_threadpool  engine/unit_test/unit_test_threadpool.cpp)
add_executable(unit_test_event       engine/unit_test/unit_test_event.cpp)
add_executable(unit_test_tcpsocket   engine/unit_test/unit_test_tcpsocket.cpp)
add_executable(unit_test_sslsocket   engine/unit_test/unit_test_sslsocket.cpp)
add_executable(unit_test_listing     engine/unit_test/unit_test_listing.cpp)
add_executable(unit_test_download    engine/unit_test/unit_test_download.cpp)
add_executable(unit_test_update      engine/unit_test/unit_test_update.cpp)
add_executable(unit_test_stringtable engine/unit_test/unit_test_stringtable.cpp)
add_executable(unit_test_datafile    engine/unit_test/unit_test_datafile.cpp)
add_executable(unit_test_catalog     engine/unit_test/unit_test_catalog.cpp)
add_executable(unit_test_index       engine/unit_test/unit_test_index.cpp)
add_executable(unit_test_cmdlist     engine/unit_test/unit_test_cmdlist.cpp)
add_executable(unit_test_nntp        engine/unit_test/unit_test_nntp.cpp)
add_executable(unit_test_linebuffer  engine/unit_test/unit_test_linebuffer.cpp)
add_executable(unit_test_bigfile     engine/unit_test/unit_test_bigfile.cpp)
add_executable(unit_test_filemap     engine/unit_test/unit_test_filemap.cpp)
add_executable(unit_test_filebuf     engine/unit_test/unit_test_filebuf.cpp)
add_executable(unit_test_bodyiter    engine/unit_test/unit_test_bodyiter.cpp)
add_executable(unit_test_decode      engine/unit_test/unit_test_decode.cpp)
add_executable(unit_test_filetype    engine/unit_test/unit_test_filetype.cpp)
add_executable(unit_test_throttle    engine/unit_test/unit_test_throttle.cpp)
add_executable(unit_test_engine      engine/unit_test/unit_test_engine.cpp)
add_executable(unit_test_connection  engine/unit_test/unit_test_connection.cpp)

target_link_libraries(unit_test_utf8        engine)
target_link_libraries(unit_test_uuencode    engine)
target_link_libraries(unit_test_yenc        engine)
target_link_libraries(unit_test_session     engine)
target_link_libraries(unit_test_buffer      engine)
target_link_libraries(unit_test_threadpool  engine)
target_link_libraries(unit_test_event       engine)
target_link_libraries(unit_test_tcpsocket   engine)
target_link_libraries(unit_test_sslsocket   engine)
target_link_libraries(unit_test_listing     engine)
target_link_libraries(unit_test_download    engine)
target_link_libraries(unit_test_update      engine)
target_link_libraries(unit_test_stringtable engine)
target_link_libraries(unit_test_datafile    engine)
target_link_libraries(unit_test_catalog     engine)
target_link_libraries(unit_test_index       engine)
target_link_libraries(unit_test_cmdlist     engine)
target_link_libraries(unit_test_nntp        engine)
target_link_libraries(unit_test_linebuffer  engine)
target_link_libraries(unit_test_bigfile     engine)
target_link_libraries(unit_test_filemap     engine)
target_link_libraries(unit_test_filebuf     engine)
target_link_libraries(unit_test_bodyiter    engine)
target_link_libraries(unit_test_decode      engine)
target_link_libraries(unit_test_filetype    engine)
target_link_libraries(unit_test_throttle    engine)
target_link_libraries(unit_test_engine      engine)
target_link_libraries(unit_test_connection  engine)

add_test(NAME unit_test_utf8        COMMAND unit_test_utf8)
add_test(NAME unit_test_uuencode    COMMAND unit_test_uuencode)
add_test(NAME unit_test_yenc        COMMAND unit_test_yenc)
add_test(NAME unit_test_session     COMMAND unit_test_session)
add_test(NAME unit_test_buffer      COMMAND unit_test_buffer)
add_test(NAME unit_test_threadpool  COMMAND unit_test_threadpool)
add_test(NAME unit_test_event       COMMAND unit_test_event)
add_test(NAME unit_test_tcpsocket   COMMAND unit_test_tcpsocket)
add_test(NAME unit_test_sslsocket   COMMAND unit_test_sslsocket)
add_test(NAME unit_test_listing     COMMAND unit_test_listing)
add_test(NAME unit_test_download    COMMAND unit_test_download)
add_test(NAME unit_test_update      COMMAND unit_test_update)
add_test(NAME unit_test_stringtable COMMAND unit_test_stringtable)
add_test(NAME unit_test_datafile    COMMAND unit_test_datafile)
add_test(NAME unit_test_catalog     COMMAND unit_test_catalog)
add_test(NAME unit_test_index       COMMAND unit_test_index)
add_test(NAME unit_test_cmdlist     COMMAND unit_test_cmdlist)
add_test(NAME unit_test_nntp        COMMAND unit_test_nntp)
add_test(NAME unit_test_linebuffer  COMMAND unit_test_linebuffer)
add_test(NAME unit_test_bigfile     COMMAND unit_test_bigfile)
add_test(NAME unit_test_filemap     COMMAND unit_test_filemap)
add_test(NAME unit_test_filebuf     COMMAND unit_test_filebuf)
add_test(NAME unit_test_bodyiter    COMMAND unit_test_bodyiter)
add_test(NAME unit_test_decode      COMMAND unit_test_decode)
add_test(NAME unit_test_filetype    COMMAND unit_test_filetype)
add_test(NAME unit_test_throttle    COMMAND unit_test_throttle)
add_test(NAME unit_test_engine      COMMAND unit_test_engine)
add_test(NAME unit_test_connection  COMMAND unit_test_connection)

add_executable(unit_test_unrar  app/unit_test/unit_test_unrar.cpp)
add_executable(unit_test_unzip  app/unit_test/unit_test_unzip.cpp)

target_link_libraries(unit_test_unrar appcore)
target_link_libraries(unit_test_unzip appcore)

add_test(NAME unit_test_unrar       COMMAND unit_test_unrar)
add_test(NAME unit_test_unzip       COMMAND unit_test_unzip)

if (CMAKE_BUILD_TYPE MATCHES "Release")
    install(TARGETS newsflash join smtpclient DESTINATION "${CMAKE_CURRENT_LIST_DIR}/dist")
elseif(CMAKE_BUILD_TYPE MATCHES "Debug")
    install(TARGETS newsflash join smtpclient DESTINATION "${CMAKE_CURRENT_LIST_DIR}/dist_d")
endif()

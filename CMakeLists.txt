cmake_minimum_required(VERSION 3.0)

project(NewsflashPlus)

message(STATUS "
      ~~ Newsflash Plus ~~
     World's best newsreader!
\\\\o Brought to you by Ensisoft o//
     http://www.ensisoft.com
Copyright (c) 2010-2017 Sami Väisänen
             Ensisoft

https://github.com/ensisoft/newsflash-plus
")

if (NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Debug)
    message("         
This is the Debug build (by default)
For Release build use the following:

cmake -G \"Unix Makefiles\" -DCMAKE_BUILD_TYPE=Release
")
endif(NOT CMAKE_BUILD_TYPE)

# set this to ON when CVomit fails to work automatically.
#set(Boost_DEBUG ON)

set(Boost_USE_MULTITHREADED  ON)
set(Boost_USE_STATIC_LIBS    ON)
set(Boost_USE_STATIC_RUNTIME OFF)
# for whatever reason CVomit thinks we're using vc120... but our build chain is MSVS 2013 (vc110)
if (WIN32)
  set(Boost_COMPILER "-vc110")
endif()
set(BOOST_ROOT       "${CMAKE_CURRENT_LIST_DIR}/third_party/boost_1_51_0/sdk")
set(BOOST_INCLUDEDIR "${CMAKE_CURRENT_LIST_DIR}/third_party/boost_1_51_0/sdk/include/")
set(BOOST_LIBRARYDIR "${CMAKE_CURRENT_LIST_DIR}/third_party/boost_1_51_0/sdk/lib")


find_package(Boost REQUIRED COMPONENTS filesystem system thread regex)
if(NOT Boost_FOUND)
    message(FATAL_ERROR
"Shit. Couldn't find Boost third_party/boost_1_51_0"
    )
endif()

# If you set QT_QMAKE_EXECUTABLE to the full path to a qmake *that* qmake is used
# above all else to find the right Qt. Regardless of QTDIR or PATH.
# Setting QT_QMAKE_EXECUTABLE is *the* official way to tell CMake where the Qt
# that you want is. All else is a "find-and-guess" game if you have multiple Qt's available.
# https://public.kitware.com/pipermail/cmake/2009-March/027708.html
set(QT_QMAKE_EXECUTABLE "${CMAKE_CURRENT_LIST_DIR}/third_party/qt-4.8.6/bin/qmake")
find_package(Qt4 REQUIRED)

message(STATUS "${Boost_INCLUDE_DIRS}")
message(STATUS "${Boost_LIBRARY_DIRS}")
message(STATUS "${Boost_LIBRARIES}")

set(CMAKE_AUTOMOC ON)
set(CMAKE_AUTOUIC ON)
set(CMAKE_AUTORCC ON)

# generic include directories (same for each platform)
include_directories(BEFORE "${CMAKE_CURRENT_LIST_DIR}/third_party/qjson/include")
include_directories(BEFORE "${CMAKE_CURRENT_LIST_DIR}/third_party")
include_directories(BEFORE "${CMAKE_CURRENT_LIST_DIR}/third_party/openssl/sdk/include")
include_directories(BEFORE "${CMAKE_CURRENT_LIST_DIR}/third_party/protobuf/src")
include_directories(BEFORE "${CMAKE_CURRENT_LIST_DIR}/third_party/zlib")
include_directories(BEFORE "${Boost_INCLUDE_DIRS}")
# UI generated files do a global include for custom widgets such as the pieview. 
# so we need to add the gui folder to the include list.
include_directories(BEFORE "${CMAKE_CURRENT_LIST_DIR}/gui")
# this tells cmake to include our *current* directory which is our build directory
# in which the Qt tools (moc and uic) will spit out their generated files.
# so for example when you have "include ui_foobar.h" in your code the
# ui_foobar.h is generated by UIC and will be placed in the current dir.
set(CMAKE_INCLUDE_CURRENT_DIR ON)

# platform specific include dirs
if (WIN32)

elseif(UNIX)

endif()

# generic link directories (same for each platform)
link_directories("${CMAKE_CURRENT_LIST_DIR}/third_party/openssl/sdk/lib")
link_directories("${CMAKE_CURRENT_LIST_DIR}/third_party/boost_1_51_0/sdk/lib")

# platform specific link dirs
if (WIN32)
    # different iterator levels thus must use correct lib (either debug or release)
    if (CMAKE_BUILD_TYPE MATCHES "Release")
        link_directories("${CMAKE_CURRENT_LIST_DIR}/third_party/protobuf/vsprojects/x64/Release")
    elseif(CMAKE_BUILD_TYPE MATCHES "Debug")
        link_directories("${CMAKE_CURRENT_LIST_DIR}/third_party/protobuf/vsprojects/x64/Debug")
    endif()    
    link_directories("${CMAKE_CURRENT_LIST_DIR}/third_party/qjson/lib/Release")    
    link_directories("${CMAKE_CURRENT_LIST_DIR}/third_party/zlib/Release")            
elseif(UNIX)
    link_directories("${CMAKE_CURRENT_LIST_DIR}/third_party/protobuf/lib")    
    link_directories("${CMAKE_CURRENT_LIST_DIR}/third_party/qjson/lib")
    link_directories("${CMAKE_CURRENT_LIST_DIR}/third_party/zlib/")    
endif()

if (WIN32)
    set(LIB_OPENSSL  "ssleay32")
    set(LIB_CRYPTO   "libeay32")
    set(LIB_Z        "zlib") # note that in a very gay fashion the lib is zlib.lib and the library is zlib1.dll
    set(LIB_PROTOBUF "libprotobuf")
elseif(UNIX)
    set(LIB_OPENSSL  "ssl")
    set(LIB_CRYPTO   "crypto")
    set(LIB_Z        "z")
    set(LIB_PROTOBUF "protobuf")    
endif()

# compiler specific compiler & linker flags
if (CMAKE_COMPILER_IS_GNUCC)
    # we need -rdynamic for backtrace and backtrace_symbols
    # in order to dump a stacktrace from the ASSERT macro.
    set(CMAKE_EXE_LINKER_FLAGS    "${CMAKE_EXE_LINKER_FLAGS}    -rdynamic -pthread")
    set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -rdynamic -pthread")
    set(CMAKE_CXX_STANDARD 14)
elseif(MSVC)
    # /Zc:wchar_t  treats wchar_t as a native type
    # /Zc:wchar_t- treats wchar_t as a typedef for unsigned short.
    # Qt requires wchar_t- otherwise the types don't match. 
    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /Zc:wchar_t-")

    if (CMAKE_BUILD_TYPE MATCHES "Release")
        #  /Zi turns on the .pdb generation. We want this for the release build
        # so that we can do post-mortem debugging with the minidump (from the crash)
        # and the pdb file.
        # /FS is needed for parallel build. It forces data to be written
        # through a serialized surrogate process.
        # NOTE that the /Zi names the .pdb file as vcx0.pdb where the x is
        # the version number. So for example vc120.pdb
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /Zi")
        set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} /FS")
    
        # http://www.wintellect.com/devcenter/jrobbins/correctly-creating-native-c-release-build-pdbs
        # need to tell the linker also about the debug data.
        set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /DEBUG")
        set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /OPT:REF")
        set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /OPT:ICF")
        set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} /DEBUG")
        set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} /OPT:REF")
        set(CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} /OPT:ICF")

        # https://msdn.microsoft.com/en-us/library/fcc1zstk.aspx
        # https://msdn.microsoft.com/en-us/library/windows/desktop/ms724832(v=vs.85).aspx
        #
        # this option is needed starting with msvc2012(?) to allow the binary run on WinXP.
        # NOTE: that it seems to be enough to have this on the executable, so theres
        # no need to dick around with Qt, json, zlib settings.
        #
        # WINDOWS, creates a win32 application that uses WinMain, no console.
        # CONSOLE, creates a console application that uses main(), system created console.
        # 5.2 = Win XP 64bit version 
        set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /SUBSYSTEM:WINDOWS,5.2")
    elseif (CMAKE_BUILD_TYPE MATCHES "Release")        
        set(CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} /SUBSYSTEM:CONSOLE,5.2")
    endif()

    # if this is not defined linking problems will happen on msvc
    add_definitions(-DBOOST_ALL_NO_LIB)
endif()

# build the engine lib
file(GLOB ENGINE_SOURCE engine/*.cpp engine/*.cc)
add_library(engine STATIC ${ENGINE_SOURCE})

file(GLOB APP_SOURCE  app/*.h app/*.cpp)
file(GLOB GUI_SOURCE  gui/*.h gui/*.cpp gui/*.ui)

add_executable(newsflash 
    ${APP_SOURCE} 
    ${GUI_SOURCE}
    gui/resource.qrc
    gui/qtsingleapplication/qtsingleapplication.h
    gui/qtsingleapplication/qtsingleapplication.cpp
    gui/qtsingleapplication/qtlocalpeer.h
    gui/qtsingleapplication/qtlocalpeer.cpp
    tools/keygen/keygen.cpp
    stringlib/string.cpp)

target_link_libraries(newsflash engine)
target_link_libraries(newsflash 
    Qt4::QtCore
    Qt4::QtGui 
    Qt4::QtNetwork
    Qt4::QtXml)
target_link_libraries(newsflash ${Boost_LIBRARIES})
target_link_libraries(newsflash 
    ${LIB_PROTOBUF} 
    qjson
    ${LIB_Z}
    ${LIB_OPENSSL}
    ${LIB_CRYPTO})

# todo: build tools and unit tests

if (CMAKE_BUILD_TYPE MATCHES "Release")
    install(TARGETS newsflash DESTINATION "${CMAKE_CURRENT_LIST_DIR}/dist")
elseif(CMAKE_BUILD_TYPE MATCHES "Debug")
    install(TARGETS newsflash DESTINATION "${CMAKE_CURRENT_LIST_DIR}/dist_d")
endif()
